<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protein Pseudo-3D Viewer</title>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 8px; /* Add some padding around the whole thing */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: transparent;
        }
        
        #mainContainer {
            display: flex;
            flex-direction: row;
            align-items: flex-start; /* Align tops */
            gap: 15px; /* Space between canvas column and controls column */
            background: transparent;
        }
        
        #viewerColumn {
            display: flex;
            flex-direction: column;
            gap: 10px; /* Space between canvas and anim controls */
        }

        #canvasContainer {
            display: inline-block;
            border: 1px solid #ddd;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            background: #ffffff;
        }
        #canvas {
            background: #ffffff;
            cursor: grab;
            display: block;
        }
        #canvas:active {
            cursor: grabbing;
        }
        #canvas.recording {
            cursor: wait; /* Show wait cursor during recording */
        }

        #colorSelect {
            font-size: 12px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%; /* Make it fill its new container */
        }

        #optionsContainer {
            font-size: 12px;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px; /* Increased gap for clarity */
        }
        .toggle-item {
            display: flex;
            align-items: center;
            gap: 4px;
            width: 100%; 
        }
        .toggle-item label { 
            cursor: pointer; 
            white-space: nowrap;
            width: 50px; /* Give label a fixed width */
            flex-shrink: 0;
            font-size: 12px; /* Ensure label font size matches */
        }
        /* Style for the shadow/outline checkbox labels */
        .toggle-item label[for="shadowEnabledCheckbox"],
        .toggle-item label[for="outlineEnabledCheckbox"] {
            width: auto; /* Let it be auto-sized */
            margin-left: 5px; /* Add space next to the slider */
        }
        .toggle-item input[type="range"] {
            cursor: pointer;
            flex-grow: 1; /* Let slider fill the rest */
            width: auto; /* Let flexbox handle it */
            min-width: 0; /* Fix for flexbox overflow */
        }
        .toggle-item input[type="checkbox"] { 
            cursor: pointer; 
            margin: 0;
            flex-shrink: 0; /* Prevent checkbox from shrinking */
        }


        /* Animation Controls Container */
        #controlsContainer {
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            padding: 0 10px;
            width: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12px;
        }
        
        #trajectoryContainer {
            font-size: 12px;
        }
        
        .controlButton {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background: #f0f0f0;
            cursor: pointer;
            min-width: 60px;
            font-size: 12px;
            vertical-align: middle;
            margin-right: 5px;
            flex-shrink: 0;
        }
        .controlButton:disabled {
            cursor: not-allowed;
            background: #eee;
            color: #999;
        }
        #frameSlider {
            flex-grow: 1; 
            width: auto;
            margin: 0 10px;
            vertical-align: middle;
        }
        #frameCounter {
            color: #333;
            vertical-align: middle;
            min-width: 80px;
            display: inline-block;
            flex-shrink: 0;
        }
        #speedSelect {
            font-size: 12px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            vertical-align: middle;
            margin-left: 10px;
            flex-shrink: 0;
        }
        
        #trajectorySelect {
            font-size: 12px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            vertical-align: middle;
            width: 100%;
        }
        #trajectorySelect:disabled {
             cursor: not-allowed;
            background: #eee;
        }

        /* Right panel for all other controls */
        #rightPanelContainer {
            display: flex;
            flex-direction: column;
            gap: 15px; /* Space between control groups */
            width: 160px; /* Give it a fixed width */
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            background: #fdfdfd;
            flex-shrink: 0; /* Don't let it shrink */
        }
        
        /* Styling for groups in the right panel */
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .control-group > label {
            font-weight: 600;
            font-size: 12px;
            color: #333;
        }
        
        /* New styles for save button */
        #saveAnimationButton {
            width: 100%;
            background-color: #007bff;
            color: white;
            border: none;
            font-weight: 600;
        }
        #saveAnimationButton:hover:not(:disabled) {
            background-color: #0056b3;
        }
        #saveAnimationButton:disabled {
            background-color: #a0cfff;
            color: #f0f0f0;
        }
        
        #saveStatusMessage {
            font-size: 11px;
            color: #333;
            text-align: center;
            min-height: 14px; /* Reserve space */
        }

    </style>
</head>
<body>
    <!-- Main container to hold viewer and controls -->
    <div id="mainContainer">
        
        <!-- Left Column -->
        <div id="viewerColumn">
            <!-- Canvas -->
            <div id="canvasContainer">
                <canvas id="canvas"></canvas>
            </div>

            <!-- Animation Controls -->
            <div id="controlsContainer">
                <button id="playButton" class="controlButton">Play</button>
                <input type="range" id="frameSlider" min="0" max="0" value="0">
                <span id="frameCounter">Frame: 0 / 0</span>
                <select id="speedSelect">
                    <option value="100">1x</option>
                    <option value="50">2x</option>
                    <option value="25">4x</option>
                </select>
            </div>
        </div>
        
        <!-- Right Column -->
        <div id="rightPanelContainer">
            
            <!-- Color Select -->
            <div class="control-group">
                <label for="colorSelect">Color</label>
                <select id="colorSelect">
                    <option value="plddt">pLDDT</option>
                    <option value="rainbow">Rainbow</option>
                    <option value="chain">Chain</option>
                </select>
            </div>

            <!-- Options -->
            <div id="optionsContainer" class="control-group">
                <div class="toggle-item"> 
                    <input type="checkbox" id="rotationCheckbox">
                    <label for="rotationCheckbox">Rotate</label>
                </div>
                <div class="toggle-item">
                    <label for="lineWidthSlider">Width:</label>
                    <input type="range" id="lineWidthSlider" min="1" max="5" value="3" step="0.5">
                </div>
                <div class="toggle-item">
                     <input type="checkbox" id="shadowEnabledCheckbox">
                     <label for="shadowEnabledCheckbox">Shadow</label>
                </div>
                <!-- Outline -->
                <div class="toggle-item">
                     <input type="checkbox" id="outlineEnabledCheckbox">
                     <label for="outlineEnabledCheckbox">Outline</label>
                </div>
            </div>

            <!-- Trajectory -->
            <div id="trajectoryContainer" class="control-group">
                <label for="trajectorySelect">Trajectory</label>
                <select id="trajectorySelect">
                    <!-- Initially empty -->
                </select>
            </div>
            
            <!-- NEW: Save Animation -->
            <div id="saveAnimationContainer" class="control-group">
                <label>Export</label>
                <button id="saveAnimationButton" class="controlButton">Save Animation</button>
                <span id="saveStatusMessage"></span>
            </div>
        </div>
    </div>

    <!-- DATA_INJECTION_POINT -->

    <script>
        // ============================================================================
        // VECTOR MATH
        // ============================================================================
        class Vec3 {
            constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
            add(v) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }
            sub(v) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }
            mul(s) { return new Vec3(this.x * s, this.y * s, this.z * s); }
            dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z; }
            length() { return Math.sqrt(this.dot(this)); }
            distanceTo(v) { return this.sub(v).length(); }
            distanceToSq(v) { const s = this.sub(v); return s.dot(s); }
            normalize() { 
                const len = this.length(); 
                return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 1); 
            }
        }
        function rotationMatrixX(angle) { const c = Math.cos(angle), s = Math.sin(angle); return [[1,0,0], [0,c,-s], [0,s,c]]; }
        function rotationMatrixY(angle) { const c = Math.cos(angle), s = Math.sin(angle); return [[c,0,s], [0,1,0], [-s,0,c]]; }
        function multiplyMatrices(a, b) { const r = [[0,0,0],[0,0,0],[0,0,0]]; for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) for (let k = 0; k < 3; k++) r[i][j] += a[i][k] * b[k][j]; return r; }
        function applyMatrix(m, v) { return new Vec3(m[0][0]*v.x + m[0][1]*v.y + m[0][2]*v.z, m[1][0]*v.x + m[1][1]*v.y + m[1][2]*v.z, m[2][0]*v.x + m[2][1]*v.y + m[2][2]*v.z); }
        function sigmoid(x) { return 0.5 + x / (2 * (1 + Math.abs(x))); }
        // ============================================================================
        // COLOR UTILITIES
        // ============================================================================
        const pymolColors = ["#33ff33","#00ffff","#ff33cc","#ffff00","#ff9999","#e5e5e5","#7f7fff","#ff7f00","#7fff7f","#199999","#ff007f","#ffdd5e","#8c3f99","#b2b2b2","#007fff","#c4b200","#8cb266","#00bfbf","#b27f7f","#fcd1a5","#ff7f7f","#ffbfdd","#7fffff","#ffff7f","#00ff7f","#337fcc","#d8337f","#bfff3f","#ff7fff","#d8d8ff","#3fffbf","#b78c4c","#339933","#66b2b2","#ba8c84","#84bf00","#b24c66","#7f7f7f","#3f3fa5","#a5512b"];
        function hexToRgb(hex) { if (!hex || typeof hex !== 'string') { return {r: 128, g: 128, b: 128}; } const r = parseInt(hex.slice(1,3), 16); const g = parseInt(hex.slice(3,5), 16); const b = parseInt(hex.slice(5,7), 16); return {r, g, b}; }
        function hsvToRgb(h, s, v) { const c = v * s; const x = c * (1 - Math.abs((h / 60) % 2 - 1)); const m = v - c; let r, g, b; if (h < 60) { r = c; g = x; b = 0; } else if (h < 120) { r = x; g = c; b = 0; } else if (h < 180) { r = 0; g = c; b = x; } else if (h < 240) { r = 0; g = x; b = c; } else if (h < 300) { r = x; g = 0; b = c; } else { r = c; g = 0; b = x; } return { r: Math.round((r + m) * 255), g: Math.round((g + m) * 255), b: Math.round((b + m) * 255) }; }
        function getRainbowColor(value, min, max) { if (max - min < 1e-6) return hsvToRgb(0, 1.0, 1.0); let normalized = (value - min) / (max - min); normalized = Math.max(0, Math.min(1, normalized)); const hue = 240 * normalized; return hsvToRgb(hue, 1.0, 1.0); }
        function getPlddtColor(plddt) { return getRainbowColor(plddt, 50, 90); }
        function getChainColor(chainIndex) { if (chainIndex < 0) chainIndex = 0; return hexToRgb(pymolColors[chainIndex % pymolColors.length]); }

        // ============================================================================
        // PSEUDO-3D RENDERER
        // ============================================================================
        class Pseudo3DRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // Get config from Python
                const config = window.viewerConfig || { 
                    size: [800, 600], 
                    color: "plddt", 
                    default_shadow: true, 
                    default_outline: true,
                    default_width: 3.0,
                    default_rotate: false,
                    hide_controls: false,
                    autoplay: false,
                    hide_box: false
                };

                // Current render state
                this.coords = []; // This is now an array of Vec3 objects
                this.plddts = [];
                this.chains = [];
                this.atomTypes = [];
                
                // Viewer state
                this.colorMode = config.color; // Set initial color from config
                this.rotationMatrix = [[1,0,0],[0,1,0],[0,0,1]];
                this.zoom = 1.0;
                this.lineWidth = (typeof config.default_width === 'number') ? config.default_width : 3.0;
                this.shadowIntensity = 0.95;
                
                // Set defaults from config, with fallback
                this.shadowEnabled = (typeof config.default_shadow === 'boolean') ? config.default_shadow : true;
                this.outlineEnabled = (typeof config.default_outline === 'boolean') ? config.default_outline : true;
                
                this.isTransparent = false; // Default to white background
                
                // Performance
                this.chainRainbowScales = {};
                this.perChainIndices = []; // <-- ADDED FOR RAINBOW FIX
                this.rotatedCoords = []; 
                this.segmentIndices = []; 
                this.segData = []; 
                this.colors = []; 
                this.plddtColors = []; 

                // Animation & State
                this.trajectoriesData = {}; 
                this.currentTrajectoryName = null; 
                this.currentFrame = -1;
                
                // Playback
                this.isPlaying = false;
                this.animationSpeed = 100; // ms per frame
                this.lastFrameAdvanceTime = 0;
                
                // Interaction
                this.isDragging = false;
                this.autoRotate = (typeof config.default_rotate === 'boolean') ? config.default_rotate : false; 
                
                this.autoplay = (typeof config.autoplay === 'boolean') ? config.autoplay : false; 
                
                // Inertia
                this.spinVelocityX = 0;
                this.spinVelocityY = 0;
                this.lastDragTime = 0;
                this.lastDragX = 0;
                this.lastDragY = 0;
                
                // Track slider interaction
                this.isSliderDragging = false;
                
                // NEW: Recording state
                this.isRecording = false;
                // this.recordingFrame = 0; // REMOVED
                this.recorder = null;
                this.recorderChunks = [];
                this.recorderOriginalState = {};
                
                // NEW: Touch zoom state
                this.lastTouchDistance = 0;

                // UI elements
                this.playButton = null;
                this.frameSlider = null;
                this.frameCounter = null;
                this.trajectorySelect = null;
                this.controlsContainer = null;
                this.speedSelect = null;
                this.rotationCheckbox = null;
                this.lineWidthSlider = null;
                this.shadowEnabledCheckbox = null; 
                this.outlineEnabledCheckbox = null; 
                this.saveAnimationButton = null; // NEW
                this.saveStatusMessage = null; // NEW

                this.setupInteraction();
            }

            setClearColor(isTransparent) {
                this.isTransparent = isTransparent;
                this.render(); // Re-render with new clear color
            }

            setupInteraction() {
                // Add inertia logic
                this.canvas.addEventListener('mousedown', (e) => {
                    // Only start dragging if we clicked directly on the canvas
                    if (e.target !== this.canvas) return;
                    // NEW: Don't drag if recording
                    if (this.isRecording) return;
                    
                    this.isDragging = true;
                    this.spinVelocityX = 0;
                    this.spinVelocityY = 0;
                    this.lastDragX = e.clientX;
                    this.lastDragY = e.clientY;
                    this.lastDragTime = performance.now();
                    if (this.autoRotate) {
                        this.autoRotate = false;
                        if (this.rotationCheckbox) this.rotationCheckbox.checked = false;
                    }
                });

                window.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return; // Also handles isRecording, since isDragging won't be set
                    
                    // Stop canvas drag if interacting with controls
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON') {
                        this.isDragging = false;
                        return;
                    }
                    
                    const now = performance.now();
                    const timeDelta = now - this.lastDragTime;

                    const dx = e.clientX - this.lastDragX;
                    const dy = e.clientY - this.lastDragY;
                    
                    if (dy !== 0) { const rot = rotationMatrixX(dy * 0.01); this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix); }
                    if (dx !== 0) { const rot = rotationMatrixY(dx * 0.01); this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix); }

                    // Store velocity for inertia
                    if (timeDelta > 0) {
                        // Weighted average to smooth out jerky movements
                        const smoothing = 0.5;
                        this.spinVelocityX = (this.spinVelocityX * (1-smoothing)) + ((dx / timeDelta * 20) * smoothing);
                        this.spinVelocityY = (this.spinVelocityY * (1-smoothing)) + ((dy / timeDelta * 20) * smoothing);
                    }

                    this.lastDragX = e.clientX;
                    this.lastDragY = e.clientY;
                    this.lastDragTime = now;
                    
                    this.render(); 
                });
                
                window.addEventListener('mouseup', () => {
                    // NEW: Don't stop drag if recording (though it shouldn't start)
                    if (this.isRecording) return;
                    
                    this.isDragging = false;
                    const now = performance.now();
                    const timeDelta = now - this.lastDragTime;
                    
                    if (timeDelta > 100) { // If drag was too slow, or just a click
                        this.spinVelocityX = 0;
                        this.spinVelocityY = 0;
                    }
                    // Else, the velocity from the last mousemove is used by the animate loop
                });

                this.canvas.addEventListener('wheel', (e) => {
                    // NEW: Don't zoom if recording
                    if (this.isRecording) return;
                    
                    e.preventDefault();
                    this.zoom *= (1 - e.deltaY * 0.001);
                    this.zoom = Math.max(0.1, Math.min(5, this.zoom));
                    this.render();
                }, { passive: false });
                
                // --- NEW: Add Touch Events for Mobile ---
                
                this.canvas.addEventListener('touchstart', (e) => {
                    // Only start dragging if we clicked directly on the canvas
                    if (e.target !== this.canvas) return;
                    // Don't drag if recording
                    if (this.isRecording) return;
                    
                    // Prevent page scroll
                    e.preventDefault();
                    
                    if (e.touches.length === 1) { // Only respond to single-touch drag
                        this.isDragging = true;
                        this.spinVelocityX = 0;
                        this.spinVelocityY = 0;
                        this.lastDragX = e.touches[0].clientX;
                        this.lastDragY = e.touches[0].clientY;
                        this.lastDragTime = performance.now();
                        if (this.autoRotate) {
                            this.autoRotate = false;
                            if (this.rotationCheckbox) this.rotationCheckbox.checked = false;
                        }
                    } else if (e.touches.length === 2) { // NEW: Handle pinch-to-zoom start
                        this.isDragging = false; // Stop rotation
                        const t1 = e.touches[0];
                        const t2 = e.touches[1];
                        const dx = t1.clientX - t2.clientX;
                        const dy = t1.clientY - t2.clientY;
                        this.lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
                    }
                }, { passive: false }); // Need passive: false to allow preventDefault

                this.canvas.addEventListener('touchmove', (e) => {
                    // Prevent page scroll
                    e.preventDefault();

                    if (e.touches.length === 1 && this.isDragging) { // Handle 1-finger drag
                        const now = performance.now();
                        const timeDelta = now - this.lastDragTime;

                        const dx = e.touches[0].clientX - this.lastDragX;
                        const dy = e.touches[0].clientY - this.lastDragY;
                        
                        if (dy !== 0) { const rot = rotationMatrixX(dy * 0.01); this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix); }
                        if (dx !== 0) { const rot = rotationMatrixY(dx * 0.01); this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix); }

                        // Store velocity for inertia
                        if (timeDelta > 0) {
                            const smoothing = 0.5;
                            this.spinVelocityX = (this.spinVelocityX * (1-smoothing)) + ((dx / timeDelta * 20) * smoothing);
                            this.spinVelocityY = (this.spinVelocityY * (1-smoothing)) + ((dy / timeDelta * 20) * smoothing);
                        }

                        this.lastDragX = e.touches[0].clientX;
                        this.lastDragY = e.touches[0].clientY;
                        this.lastDragTime = now;
                        
                        this.render(); 
                    } else if (e.touches.length === 2 && !this.isRecording) { // NEW: Handle 2-finger pinch-to-zoom
                        const t1 = e.touches[0];
                        const t2 = e.touches[1];
                        const dx = t1.clientX - t2.clientX;
                        const dy = t1.clientY - t2.clientY;
                        const newTouchDistance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (this.lastTouchDistance > 0) {
                            const delta = newTouchDistance - this.lastTouchDistance;
                            this.zoom *= (1 + delta * 0.005); // Adjust zoom based on pinch
                            this.zoom = Math.max(0.1, Math.min(5, this.zoom));
                            this.render();
                        }
                        
                        this.lastTouchDistance = newTouchDistance;
                    }
                }, { passive: false }); // Need passive: false to allow preventDefault

                this.canvas.addEventListener('touchend', (e) => {
                    // Don't stop drag if recording
                    if (this.isRecording) return;
                    
                    this.isDragging = false;
                    const now = performance.now();
                    const timeDelta = now - this.lastDragTime;
                    
                    if (timeDelta > 100) { // If drag was too slow, or just a click
                        this.spinVelocityX = 0;
                        this.spinVelocityY = 0;
                    }
                    // Else, inertia will take over
                    
                    // NEW: Reset pinch zoom tracking
                    if (e.touches.length < 2) {
                        this.lastTouchDistance = 0;
                    }
                });
            }

            // Set UI controls from main script
            setUIControls(controlsContainer, playButton, frameSlider, frameCounter, trajectorySelect, speedSelect, rotationCheckbox, lineWidthSlider, shadowEnabledCheckbox, outlineEnabledCheckbox, saveAnimationButton, saveStatusMessage) {
                this.controlsContainer = controlsContainer;
                this.playButton = playButton;
                this.frameSlider = frameSlider;
                this.frameCounter = frameCounter;
                this.trajectorySelect = trajectorySelect;
                this.speedSelect = speedSelect;
                this.rotationCheckbox = rotationCheckbox;
                this.lineWidthSlider = lineWidthSlider;
                this.shadowEnabledCheckbox = shadowEnabledCheckbox; 
                this.outlineEnabledCheckbox = outlineEnabledCheckbox;
                this.saveAnimationButton = saveAnimationButton; // NEW
                this.saveStatusMessage = saveStatusMessage; // NEW
                
                this.lineWidth = parseFloat(this.lineWidthSlider.value); // Read default from slider
                this.autoRotate = this.rotationCheckbox.checked; // Read default from checkbox

                // Bind all event listeners
                this.playButton.addEventListener('click', () => {
                    this.togglePlay();
                });
                
                // NEW: Save button listener
                this.saveAnimationButton.addEventListener('click', () => {
                    this.saveAnimation();
                });

                this.trajectorySelect.addEventListener('change', () => {
                    this.stopAnimation();
                    this.currentTrajectoryName = this.trajectorySelect.value;
                    this.setFrame(0);
                });

                this.speedSelect.addEventListener('change', (e) => {
                    this.animationSpeed = parseInt(e.target.value);
                });

                this.rotationCheckbox.addEventListener('change', (e) => {
                    this.autoRotate = e.target.checked;
                    // Stop inertia if user clicks auto-rotate
                    this.spinVelocityX = 0;
                    this.spinVelocityY = 0;
                });

                this.lineWidthSlider.addEventListener('input', (e) => {
                    this.lineWidth = parseFloat(e.target.value);
                    if (!this.isPlaying) {
                        this.render();
                    }
                });

                if (this.shadowEnabledCheckbox) {
                    this.shadowEnabledCheckbox.addEventListener('change', (e) => {
                        this.shadowEnabled = e.target.checked;
                        this.render();
                    });
                }

                if (this.outlineEnabledCheckbox) {
                    this.outlineEnabledCheckbox.addEventListener('change', (e) => {
                        this.outlineEnabled = e.target.checked;
                        this.render();
                    });
                }

                // Prevent canvas drag from interfering with slider
                const handleSliderChange = (e) => {
                    this.stopAnimation();
                    this.setFrame(parseInt(e.target.value));
                };

                // Track when user is interacting with slider
                this.frameSlider.addEventListener('mousedown', (e) => {
                    // NEW: Check for recording
                    if (this.isRecording) return;
                    
                    this.isDragging = false;
                    this.isSliderDragging = true;
                    e.stopPropagation();
                });
                
                this.frameSlider.addEventListener('mouseup', (e) => {
                    this.isSliderDragging = false;
                });
                
                // Also clear on window mouseup in case user releases outside slider
                window.addEventListener('mouseup', () => {
                    this.isSliderDragging = false;
                });
                
                this.frameSlider.addEventListener('input', handleSliderChange);
                this.frameSlider.addEventListener('change', handleSliderChange);
                
                // Also prevent canvas drag when interacting with other controls
                const allControls = [this.playButton, this.trajectorySelect, this.speedSelect, 
                                     this.rotationCheckbox, this.lineWidthSlider, 
                                     this.shadowEnabledCheckbox, this.outlineEnabledCheckbox,
                                     this.saveAnimationButton]; // NEW
                allControls.forEach(control => {
                    if (control) {
                        control.addEventListener('mousedown', (e) => {
                            // NEW: Check for recording
                            if (this.isRecording) return;
                            
                            this.isDragging = false;
                            e.stopPropagation();
                        });
                    }
                });
            }
            
            // NEW: saveAnimation method (Refactored)
            saveAnimation() {
                if (this.isRecording) return; // Already recording
                
                if (typeof window.MediaRecorder === 'undefined') {
                    this.saveStatusMessage.textContent = "Recording not supported.";
                    setTimeout(() => { this.saveStatusMessage.textContent = ""; }, 3000);
                    return;
                }
                
                if (!this.currentTrajectoryName) {
                    this.saveStatusMessage.textContent = "No trajectory loaded.";
                     setTimeout(() => { this.saveStatusMessage.textContent = ""; }, 3000);
                    return;
                }
                
                const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                if (!trajectory || trajectory.frames.length < 2) {
                     this.saveStatusMessage.textContent = "Need >1 frame to save.";
                     setTimeout(() => { this.saveStatusMessage.textContent = ""; }, 3000);
                    return;
                }
                
                this.isRecording = true;
                this.canvas.classList.add('recording');
                
                // Store original state
                this.recorderOriginalState = {
                    frame: this.currentFrame,
                    playing: this.isPlaying,
                    rotating: this.autoRotate
                };
                
                // Set to known state for recording
                this.stopAnimation();
                this.autoRotate = false;
                this.spinVelocityX = 0;
                this.spinVelocityY = 0;
                this.setUIEnabled(false); // Disable all controls
                this.saveStatusMessage.textContent = "Starting recorder...";
                
                this.recorderChunks = [];
                let recorder;
                
                // Request 50 Mbps bitrate (50 * 1024 * 1024)
                const targetBitrate = 50 * 1024 * 1024;
                
                // Calculate FPS from selected speed
                const fps = 1000 / this.animationSpeed;
                
                // Restore state function (callable on error or stop)
                const restoreState = (message) => {
                    this.saveStatusMessage.textContent = message;
                    
                    this.isRecording = false;
                    // this.recordingFrame = 0; // REMOVED
                    this.recorder = null;
                    this.recorderChunks = [];
                    this.canvas.classList.remove('recording');
                    
                    // Restore original state
                    this.setFrame(this.recorderOriginalState.frame);
                    if (this.recorderOriginalState.playing) this.startAnimation();
                    this.autoRotate = this.recorderOriginalState.rotating;
                    this.setUIEnabled(true); // Re-enable controls
                    
                    setTimeout(() => { this.saveStatusMessage.textContent = ""; }, 3000);
                };
                
                // Try to get a high-quality vp9 stream first
                try {
                    const stream = this.canvas.captureStream(fps);
                    const options = { mimeType: 'video/webm; codecs=vp9', bitsPerSecond: targetBitrate };
                    recorder = new MediaRecorder(stream, options);
                } catch (e1) {
                    console.warn(`VP9 @ ${fps}fps/50Mbps failed, trying VP8...`, e1);
                    try {
                        const stream = this.canvas.captureStream(fps);
                        const options = { mimeType: 'video/webm; codecs=vp8', bitsPerSecond: targetBitrate };
                        recorder = new MediaRecorder(stream, options);
                    } catch (e2) {
                        console.error(`VP8 @ ${fps}fps/50Mbps failed, trying default...`, e2);
                        try {
                            // Fallback to default (might not respect bitrate)
                            const stream = this.canvas.captureStream(fps);
                            recorder = new MediaRecorder(stream, { mimeType: 'video/webm', bitsPerSecond: targetBitrate });
                        } catch (e3) {
                             console.error("Failed to create MediaRecorder:", e3);
                             restoreState("Recorder failed.");
                             return;
                        }
                    }
                }

                this.recorder = recorder; // Store instance

                recorder.ondataavailable = e => {
                    if (e.data.size > 0) {
                        this.recorderChunks.push(e.data);
                    }
                };

                recorder.onstop = () => {
                    const blob = new Blob(this.recorderChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${this.currentTrajectoryName}.webm`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    restoreState("Save complete!");
                };
                
                recorder.start();
                
                // --- Start the recording process ---
                // Set to frame 0 and start the player.
                // The animate() loop will catch the 'isRecording' flag
                // and stop the recorder when the animation loops.
                this.setFrame(0); // Render the first frame (index 0)
                this.saveStatusMessage.textContent = `Recording... 1 / ${trajectory.frames.length}`;
                this.startAnimation(); // This will drive the frame-by-frame rendering
            }


            // Add a new trajectory
            addTrajectory(name) {
                this.stopAnimation();
                this.trajectoriesData[name] = { maxExtent: 0, frames: [], globalCenterSum: new Vec3(0,0,0), totalAtoms: 0 };
                this.currentTrajectoryName = name;
                this.currentFrame = -1;

                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                this.trajectorySelect.appendChild(option);
                this.trajectorySelect.value = name;

                this.setFrame(-1);
            }

            // Add a frame (data is raw parsed JSON)
            addFrame(data, trajectoryName) {
                
                let targetTrajectoryName = trajectoryName;
                if (!targetTrajectoryName) {
                    console.warn("addFrame called without trajectoryName, using current view.");
                    targetTrajectoryName = this.currentTrajectoryName;
                }
                
                if (!targetTrajectoryName) {
                    // This can happen if addFrame is called before new_traj
                    console.warn("addFrame: No trajectory active. Creating '0'.");
                    this.addTrajectory("0");
                    targetTrajectoryName = "0";
                }
                
                if (!this.trajectoriesData[targetTrajectoryName]) {
                     console.error(`addFrame: Trajectory '${targetTrajectoryName}' does not exist.`);
                     console.warn(`addFrame: Trajectory '${targetTrajectoryName}' not found. Creating it.`);
                     this.addTrajectory(targetTrajectoryName);
                }

                const trajectory = this.trajectoriesData[targetTrajectoryName];
                trajectory.frames.push(data);

                // Set view to this trajectory
                if (this.currentTrajectoryName !== targetTrajectoryName) {
                    this.stopAnimation(); // Stop if playing on another traj
                    this.currentTrajectoryName = targetTrajectoryName;
                    this.trajectorySelect.value = targetTrajectoryName;
                }

                // Update global center sum and count
                let frameSum = new Vec3(0,0,0);
                let frameAtoms = 0;
                if (data && data.coords) {
                    frameAtoms = data.coords.length;
                    for (let i = 0; i < data.coords.length; i++) {
                        const c = data.coords[i];
                        frameSum = frameSum.add(new Vec3(c[0], c[1], c[2]));
                    }
                    trajectory.globalCenterSum = trajectory.globalCenterSum.add(frameSum);
                    trajectory.totalAtoms += frameAtoms;
                }
                
                const globalCenter = (trajectory.totalAtoms > 0) ? trajectory.globalCenterSum.mul(1 / trajectory.totalAtoms) : new Vec3(0,0,0);

                // Recalculate maxExtent for all frames using the new global center
                let maxDistSq = 0;
                for (const frame of trajectory.frames) {
                    if (frame && frame.coords) {
                        for (let i = 0; i < frame.coords.length; i++) {
                            const c = frame.coords[i];
                            const coordVec = new Vec3(c[0], c[1], c[2]);
                            const centeredCoord = coordVec.sub(globalCenter);
                            const distSq = centeredCoord.dot(centeredCoord);
                            if (distSq > maxDistSq) maxDistSq = distSq;
                        }
                    }
                }
                trajectory.maxExtent = Math.sqrt(maxDistSq);

                if (!this.isPlaying) {
                    this.setFrame(trajectory.frames.length - 1);
                }
                this.updateUIControls();

                // Handle autoplay
                if (this.autoplay && !this.isPlaying && this.currentTrajectoryName) {
                    // Check if the current trajectory now has multiple frames
                    const traj = this.trajectoriesData[this.currentTrajectoryName];
                    if (traj && traj.frames.length > 1) {
                        this.startAnimation();
                    }
                }
            }

            // Set the current frame and render it
            setFrame(frameIndex) {
                frameIndex = parseInt(frameIndex);
                
                // Handle clearing the canvas based on transparency
                const clearCanvas = () => {
                    if (this.isTransparent) {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    } else {
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    }
                };
                
                // Handle null trajectory name
                if (!this.currentTrajectoryName) {
                    this.currentFrame = -1;
                    this.coords = [];
                    clearCanvas();
                    this.updateUIControls();
                    // Prevent "spinning wheel" on reload
                    this.setUIEnabled(true); 
                    return;
                }

                const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                if (!trajectory || frameIndex < 0 || frameIndex >= trajectory.frames.length) {
                    this.currentFrame = -1;
                    this.coords = [];
                    clearCanvas();
                    this.updateUIControls();
                    this.setUIEnabled(true); // Enable, even if frame is invalid (so user can change traj)
                    return;
                }

                this.currentFrame = frameIndex;
                const data = trajectory.frames[frameIndex];
                this._loadDataIntoRenderer(data); // This calls render()
                this.updateUIControls(); // Update slider value
                
                // NEW: Only enable UI if not recording
                if (!this.isRecording) {
                    this.setUIEnabled(true); // Make sure controls are enabled
                }
            }

            // Update UI element states (e.g., disabled)
            setUIEnabled(enabled) {
                 // NEW: Don't re-enable if we are in a recording state
                 if (this.isRecording && enabled) return;
                 
                 this.playButton.disabled = !enabled;
                 this.frameSlider.disabled = !enabled;
                 this.trajectorySelect.disabled = !enabled;
                 this.speedSelect.disabled = !enabled;
                 this.rotationCheckbox.disabled = !enabled;
                 this.lineWidthSlider.disabled = !enabled;
                 if (this.shadowEnabledCheckbox) this.shadowEnabledCheckbox.disabled = !enabled;
                 if (this.outlineEnabledCheckbox) this.outlineEnabledCheckbox.disabled = !enabled;
                 if (this.saveAnimationButton) this.saveAnimationButton.disabled = !enabled; // NEW
                 
                 // Update cursor based on recording state OR enabled state
                 if (this.isRecording) {
                    this.canvas.style.cursor = 'wait';
                 } else {
                    this.canvas.style.cursor = enabled ? 'grab' : 'wait';
                 }
            }

            // Update the text/slider values
            updateUIControls() {
                if (!this.playButton) return;

                // Handle null trajectory
                const trajectory = this.currentTrajectoryName ? this.trajectoriesData[this.currentTrajectoryName] : null;
                const total = trajectory ? trajectory.frames.length : 0;
                const current = Math.max(0, this.currentFrame) + 1;

                // Check config.hide_controls before showing
                const config = window.viewerConfig || {};
                if (total <= 1 || config.hide_controls) {
                    this.controlsContainer.style.display = 'none';
                    // NEW: Hide save button if not a trajectory
                    if (this.saveAnimationButton) {
                        this.saveAnimationButton.parentElement.style.display = 'none';
                    }
                } else {
                    this.controlsContainer.style.display = 'flex';
                     // NEW: Show save button if it's a trajectory
                    if (this.saveAnimationButton) {
                         this.saveAnimationButton.parentElement.style.display = 'flex';
                    }
                }

                this.frameSlider.max = Math.max(0, total - 1);
                
                // Don't update slider value while user is dragging it
                if (!this.isSliderDragging) {
                    this.frameSlider.value = this.currentFrame;
                }
                
                this.frameCounter.textContent = `Frame: ${total > 0 ? current : 0} / ${total}`;
                this.playButton.textContent = this.isPlaying ? 'Pause' : 'Play';
            }

            // Toggle play/pause
            togglePlay() {
                if (this.isPlaying) {
                    this.stopAnimation();
                } else {
                    this.startAnimation();
                }
            }

            // Start playback
            startAnimation() {
                // Check for null
                if (!this.currentTrajectoryName) return;
                const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                if (!trajectory || trajectory.frames.length < 2) return;

                this.isPlaying = true;
                this.lastFrameAdvanceTime = performance.now(); // Set start time
                this.updateUIControls();
            }

            // Stop playback
            stopAnimation() {
                this.isPlaying = false;
                this.updateUIControls();
            }

            // Clear all trajectories
            clearAllTrajectories() {
                this.stopAnimation();
                
                // Reset data
                this.trajectoriesData = {};
                this.currentTrajectoryName = null;
                
                // Reset trajectory dropdown
                if (this.trajectorySelect) {
                    this.trajectorySelect.innerHTML = ''; // Clear all options
                }
                
                // Set to empty frame, which clears canvas and updates UI
                this.setFrame(-1);
            }

            _loadDataIntoRenderer(data) {
                try {
                    if (data && data.coords && data.coords.length > 0) {
                        const coords = data.coords.map(c => new Vec3(c[0], c[1], c[2]));
                        const plddts = data.plddts || [];
                        const chains = data.chains || [];
                        const atomTypes = data.atom_types || [];
                        this.setCoords(coords, plddts, chains, atomTypes);
                    }
                } catch (e) {
                    console.error("Failed to load data into renderer:", e);
                }
            }

            setCoords(coords, plddts = [], chains = [], atomTypes = []) {
                this.coords = coords;
                this.plddts = plddts;
                this.chains = chains;
                this.atomTypes = atomTypes;
                
                const n = this.coords.length;

                // Handle defaults
                if (this.plddts.length !== n) { this.plddts = Array(n).fill(50.0); }
                if (this.chains.length !== n) { this.chains = Array(n).fill('A'); }
                if (this.atomTypes.length !== n) { this.atomTypes = Array(n).fill('P'); }

                // --- FIX 1 START ---
                // Pre-calculate per-chain indices for rainbow coloring (N-to-C)
                this.perChainIndices = new Array(n);
                const chainIndices = {}; // Temporary tracker
                for (let i = 0; i < n; i++) {
                    const type = this.atomTypes[i];
                    if (type === 'P' || type === 'D' || type === 'R') {
                        const chainId = this.chains[i] || 'A';
                        if (chainIndices[chainId] === undefined) {
                            chainIndices[chainId] = 0;
                        }
                        this.perChainIndices[i] = chainIndices[chainId];
                        chainIndices[chainId]++;
                    } else {
                        this.perChainIndices[i] = 0; // Default for ligands
                    }
                }
                // --- FIX 1 END ---

                // Pre-calculate rainbow scales
                this.chainRainbowScales = {};
                for (let i = 0; i < this.atomTypes.length; i++) {
                    const type = this.atomTypes[i];
                    if (type === 'P' || type === 'D' || type === 'R') {
                        const chainId = this.chains[i] || 'A';
                        if (!this.chainRainbowScales[chainId]) { 
                            this.chainRainbowScales[chainId] = { min: Infinity, max: -Infinity }; 
                        }
                        // --- FIX 2: Use per-chain N-to-C index ---
                        const colorIndex = this.perChainIndices[i]; 
                        const scale = this.chainRainbowScales[chainId];
                        scale.min = Math.min(scale.min, colorIndex);
                        scale.max = Math.max(scale.max, colorIndex);
                    }
                }
                
                // Pre-allocate rotatedCoords array
                if (this.rotatedCoords.length !== n) {
                    this.rotatedCoords = Array.from({ length: n }, () => new Vec3(0, 0, 0));
                }

                // Generate Segment Definitions ONCE
                this.segmentIndices = [];
                const proteinChainbreak = 5.0;
                const nucleicChainbreak = 7.5;
                const ligandBondCutoff = 2.0;
                const proteinChainbreakSq = proteinChainbreak * proteinChainbreak;
                const nucleicChainbreakSq = nucleicChainbreak * nucleicChainbreak;
                const ligandBondCutoffSq = ligandBondCutoff * ligandBondCutoff;
                
                let firstPolymerIndex = -1;
                let lastPolymerIndex = -1;
                const ligandIndices = [];
                
                const isPolymer = (type) => (type === 'P' || type === 'D' || type === 'R');
                const isPolymerArr = this.atomTypes.map(isPolymer);
                
                const getChainbreakDistSq = (type1, type2) => {
                    if ((type1 === 'D' || type1 === 'R') && (type2 === 'D' || type2 === 'R')) {
                        return nucleicChainbreakSq;
                    }
                    return proteinChainbreakSq;
                };
                
                for (let i = 0; i < n; i++) {
                    if (isPolymerArr[i]) {
                        const type = this.atomTypes[i];
                        if (firstPolymerIndex === -1) { firstPolymerIndex = i; }
                        lastPolymerIndex = i;
                        
                        if (i < n - 1) {
                            if (isPolymerArr[i+1]) {
                                const type1 = type;
                                const type2 = this.atomTypes[i+1];
                                const samePolymerType = (type1 === type2) || 
                                    ((type1 === 'D' || type1 === 'R') && (type2 === 'D' || type2 === 'R'));
                                
                                if (samePolymerType && this.chains[i] === this.chains[i+1]) {
                                    const start = this.coords[i];
                                    const end = this.coords[i+1];
                                    const distSq = start.distanceToSq(end);
                                    const chainbreakDistSq = getChainbreakDistSq(type1, type2);
                                    
                                    if (distSq < chainbreakDistSq) {
                                        this.segmentIndices.push({ 
                                            idx1: i, 
                                            idx2: i+1, 
                                            // --- FIX 3: Use per-chain N-to-C index ---
                                            colorIndex: this.perChainIndices[i], 
                                            origIndex: i, 
                                            chainId: this.chains[i] || 'A',
                                            type: type1,
                                            len: Math.sqrt(distSq)
                                        });
                                    }
                                }
                            }
                        }
                    } else if (this.atomTypes[i] === 'L') {
                        ligandIndices.push(i);
                    }
                }

                if (firstPolymerIndex !== -1 && lastPolymerIndex !== -1 && firstPolymerIndex !== lastPolymerIndex) {
                    const firstChainId = this.chains[firstPolymerIndex] || 'A';
                    const lastChainId = this.chains[lastPolymerIndex] || 'A';
                    
                    if (firstChainId === lastChainId && isPolymerArr[firstPolymerIndex] && isPolymerArr[lastPolymerIndex]) {
                        const type1 = this.atomTypes[firstPolymerIndex];
                        const type2 = this.atomTypes[lastPolymerIndex];
                        const samePolymerType = (type1 === type2) || 
                            ((type1 === 'D' || type1 === 'R') && (type2 === 'D' || type2 === 'R'));
                        
                        if (samePolymerType) {
                            const start = this.coords[firstPolymerIndex];
                            const end = this.coords[lastPolymerIndex];
                            const distSq = start.distanceToSq(end);
                            const chainbreakDistSq = getChainbreakDistSq(type1, type2);
                            
                            if (distSq < chainbreakDistSq) {
                                this.segmentIndices.push({ 
                                    idx1: firstPolymerIndex, 
                                    idx2: lastPolymerIndex,
                                    // --- FIX 4: Use per-chain N-to-C index ---
                                    colorIndex: this.perChainIndices[firstPolymerIndex],
                                    origIndex: firstPolymerIndex, 
                                    chainId: firstChainId,
                                    type: type1,
                                    len: Math.sqrt(distSq)
                                });
                            }
                        }
                    }
                }

                for (let i = 0; i < ligandIndices.length; i++) {
                    for (let j = i + 1; j < ligandIndices.length; j++) {
                        const idx1 = ligandIndices[i];
                        const idx2 = ligandIndices[j];
                        const start = this.coords[idx1];
                        const end = this.coords[idx2];
                        const distSq = start.distanceToSq(end);
                        if (distSq < ligandBondCutoffSq) {
                             this.segmentIndices.push({ 
                                 idx1: idx1, 
                                 idx2: idx2,
                                 colorIndex: 0, 
                                 origIndex: idx1, 
                                 chainId: this.chains[idx1] || 'A',
                                 type: 'L',
                                 len: Math.sqrt(distSq)
                            });
                        }
                    }
                }
                
                // Pre-allocate segData array
                const m = this.segmentIndices.length;
                if (this.segData.length !== m) {
                    this.segData = Array.from({ length: m }, () => ({
                        x: 0, y: 0, z: 0, len: 0, zVal: 0, gx: -1, gy: -1
                    }));
                }
                
                // Pre-calculate colors ONCE (if not plddt)
                this.colors = this._calculateSegmentColors();
                
                // Pre-calculate pLDDT colors
                this.plddtColors = this._calculatePlddtColors();

                // Trigger first render
                this.render(); 
            }
            
            // Calculate segment colors (chain or rainbow)
            _calculateSegmentColors() {
                const n = this.coords.length;
                const m = this.segmentIndices.length;
                
                const chainIndexMap = new Map();
                if (this.colorMode === 'chain' && this.chains.length > 0) {
                    for (const chainId of this.chains) {
                        if (chainId && !chainIndexMap.has(chainId)) {
                            chainIndexMap.set(chainId, chainIndexMap.size);
                        }
                    }
                }
                
                const grey = {r: 128, g: 128, b: 128};
                
                return this.segmentIndices.map(segInfo => {
                    const i = segInfo.origIndex;
                    const type = segInfo.type;
                    
                    if (type === 'L') {
                        // Ligands are grey unless in plddt mode
                        return grey;
                    }
                    // plddt mode is handled in render()
                    if (this.colorMode === 'chain') {
                        const chainId = this.chains[i] || 'A';
                        const chainIndex = chainIndexMap.get(chainId);
                        return getChainColor(chainIndex !== undefined ? chainIndex : 0);
                    }
                    else { // rainbow
                        const scale = this.chainRainbowScales[segInfo.chainId];
                        if (scale) { return getRainbowColor(segInfo.colorIndex, scale.min, scale.max); }
                        else { return grey; }
                    }
                });
            }

            // Calculate pLDDT colors
            _calculatePlddtColors() {
                const m = this.segmentIndices.length;
                if (m === 0) return [];
                
                const grey = {r: 128, g: 128, b: 128};
                const colors = new Array(m);
                
                for (let i = 0; i < m; i++) {
                    const segInfo = this.segmentIndices[i];
                    const atomIdx = segInfo.origIndex;
                    const type = segInfo.type;
                    
                    if (type === 'L') {
                        const plddt1 = (this.plddts[atomIdx] !== null && this.plddts[atomIdx] !== undefined) ? this.plddts[atomIdx] : 50;
                        colors[i] = getPlddtColor(plddt1);
                    } else {
                        const plddt1 = (this.plddts[atomIdx] !== null && this.plddts[atomIdx] !== undefined) ? this.plddts[atomIdx] : 50;
                        const plddt2_idx = (segInfo.idx2 < this.coords.length) ? segInfo.idx2 : segInfo.idx1;
                        const plddt2 = (this.plddts[plddt2_idx] !== null && this.plddts[plddt2_idx] !== undefined) ? this.plddts[plddt2_idx] : 50;
                        colors[i] = getPlddtColor((plddt1 + plddt2) / 2);
                    }
                }
                return colors;
            }

            // Helper function for shadow calculation
            /**
             * Calculates the shadow and tint contribution for a pair of segments.
             * @param {object} s1 - The segment being shaded (further back).
             * @param {object} s2 - The segment casting the shadow (further forward).
             * @returns {{shadow: number, tint: number}}
             */
            _calculateShadowTint(s1, s2) {
                const avgLen = (s1.len + s2.len) * 0.5;
                const shadow_cutoff = avgLen * 2.0;
                const tint_cutoff = avgLen * 0.5;
                const max_cutoff = shadow_cutoff + 10.0;
                
                // Use properties from the segment data objects
                const dx_dist = s1.x - s2.x;
                const dy_dist = s1.y - s2.y;
                
                const dist2D_sq = dx_dist * dx_dist + dy_dist * dy_dist;
                const max_cutoff_sq = max_cutoff * max_cutoff;
                
                let shadow = 0;
                let tint = 0;

                if (dist2D_sq > max_cutoff_sq) {
                    return { shadow: 0, tint: 0 };
                }
                
                const dz = s1.z - s2.z;
                const dist3D_sq = dist2D_sq + dz * dz;
                
                if (dist3D_sq < max_cutoff_sq) {
                    const dist3D = Math.sqrt(dist3D_sq);
                    shadow = sigmoid(shadow_cutoff - dist3D);
                }
                
                const tint_max_cutoff = tint_cutoff + 10.0;
                const tint_max_cutoff_sq = tint_max_cutoff * tint_max_cutoff;
                
                if (dist2D_sq < tint_max_cutoff_sq) {
                    const dist2D = Math.sqrt(dist2D_sq);
                    tint = sigmoid(tint_cutoff - dist2D);
                }

                return { shadow, tint };
            }


            // RENDER (Core drawing logic)
            render() {
                const startTime = performance.now();
                // Use clearRect or fillRect based on transparency
                if (this.isTransparent) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                } else {
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                }
                
                // Check segment length
                if (this.coords.length === 0 || this.segmentIndices.length === 0 || !this.currentTrajectoryName) return;

                const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                if (!trajectory) {
                    console.warn("Render called but trajectory data is missing.");
                    return;
                }

                const globalCenter = (trajectory && trajectory.totalAtoms > 0) ? trajectory.globalCenterSum.mul(1 / trajectory.totalAtoms) : new Vec3(0,0,0);
                
                // Update pre-allocated rotatedCoords
                const m = this.rotationMatrix;
                const c = globalCenter;
                for (let i = 0; i < this.coords.length; i++) {
                    const v = this.coords[i];
                    const subX = v.x - c.x, subY = v.y - c.y, subZ = v.z - c.z;
                    const out = this.rotatedCoords[i];
                    out.x = m[0][0]*subX + m[0][1]*subY + m[0][2]*subZ;
                    out.y = m[1][0]*subX + m[1][1]*subY + m[1][2]*subZ;
                    out.z = m[2][0]*subX + m[2][1]*subY + m[2][2]*subZ;
                }
                const rotated = this.rotatedCoords;

                // Segment generation is now just data lookup
                const n = this.segmentIndices.length;
                const segments = this.segmentIndices; // Use the pre-calculated segment definitions
                
                // Select pre-calculated color array
                let colors;
                if (this.colorMode === 'plddt') {
                    colors = this.plddtColors; // Use pre-calculated array
                } else {
                    // --- FIX: Re-calculate rainbow/chain colors if mode changed ---
                    if (!this.colors || this.colors.length !== n) {
                        this.colors = this._calculateSegmentColors();
                    }
                    colors = this.colors;
                }
                if (!colors || colors.length !== n) { // Safety check
                    colors = this.plddtColors.length === n ? this.plddtColors : (this.colors.length === n ? this.colors : []);
                    if (colors.length !== n) return; // Still bad, abort render
                }
                
                // Combine Z-value/norm and update segData
                const zValues = new Float32Array(n);
                let zMin = Infinity;
                let zMax = -Infinity;
                const segData = this.segData; // Use pre-allocated array

                for (let i = 0; i < n; i++) {
                    const segInfo = segments[i];
                    const start = rotated[segInfo.idx1];
                    const end = rotated[segInfo.idx2];
                    
                    const midX = (start.x + end.x) * 0.5;
                    const midY = (start.y + end.y) * 0.5;
                    const midZ = (start.z + end.z) * 0.5;
                    const z = midZ; // zValue is just midZ
                    
                    zValues[i] = z;
                    if (z < zMin) zMin = z;
                    if (z > zMax) zMax = z;
                    
                    // Update pre-allocated segData object
                    const s = segData[i];
                    s.x = midX;
                    s.y = midY;
                    s.z = midZ;
                    s.len = segInfo.len; // Use pre-calculated length
                    s.zVal = z;
                    // gx/gy are reset in shadow logic
                }
                
                const zNorm = new Float32Array(n);
                const zRange = zMax - zMin;
                if (zRange > 1e-6) {
                    for (let i = 0; i < n; i++) {
                        zNorm[i] = (zValues[i] - zMin) / zRange;
                    }
                } else {
                    zNorm.fill(0);
                }
                
                const renderShadows = this.shadowEnabled;
                const maxExtent = (trajectory && trajectory.maxExtent > 0) ? trajectory.maxExtent : 30.0;

                const shadows = new Float32Array(n);
                const tints = new Float32Array(n);
                const order = Array.from({length: n}, (_, i) => i).sort((a, b) => zValues[a] - zValues[b]);

                if (renderShadows) {
                    if (n <= 1000) {
                        for (let i_idx = n - 1; i_idx >= 0; i_idx--) {
                            const i = order[i_idx]; 
                            let shadowSum = 0;
                            let maxTint = 0;
                            const s1 = segData[i];

                            for (let j_idx = i_idx + 1; j_idx < n; j_idx++) {
                                const j = order[j_idx];
                                const s2 = segData[j];
                                
                                // Call helper function
                                const { shadow, tint } = this._calculateShadowTint(s1, s2);
                                shadowSum += shadow;
                                maxTint = Math.max(maxTint, tint);
                            }
                            shadows[i] = Math.pow(this.shadowIntensity, shadowSum);
                            tints[i] = 1 - maxTint;
                        }
                    } else { // n > 1000
                        let GRID_DIM = Math.ceil(Math.sqrt(n / 10)); 
                        GRID_DIM = Math.max(10, Math.min(100, GRID_DIM)); 
                        
                        const gridSize = GRID_DIM * GRID_DIM;
                        const grid = Array.from({ length: gridSize }, () => []);
                        
                        const gridMin = -maxExtent - 1.0;
                        const gridRange = (maxExtent + 1.0) * 2;
                        const gridCellSize = gridRange / GRID_DIM;
                        
                        if (gridCellSize > 1e-6) {
                            const invCellSize = 1.0 / gridCellSize; 
                            
                            for (let i = 0; i < n; i++) {
                                const s = segData[i];
                                const gx = Math.floor((s.x - gridMin) * invCellSize);
                                const gy = Math.floor((s.y - gridMin) * invCellSize);
                                
                                if (gx >= 0 && gx < GRID_DIM && gy >= 0 && gy < GRID_DIM) {
                                    s.gx = gx;
                                    s.gy = gy;
                                } else {
                                    s.gx = -1; // Mark as outside grid
                                    s.gy = -1;
                                }
                            }
                            
                            for (let i_idx = n - 1; i_idx >= 0; i_idx--) {
                                const i = order[i_idx]; 
                                let shadowSum = 0;
                                let maxTint = 0;
                                const s1 = segData[i];
                                const gx1 = s1.gx;
                                const gy1 = s1.gy;

                                if (gx1 < 0) { 
                                    shadows[i] = 1.0;
                                    tints[i] = 1.0;
                                    continue; 
                                }

                                for (let dy = -1; dy <= 1; dy++) {
                                    const gy2 = gy1 + dy;
                                    if (gy2 < 0 || gy2 >= GRID_DIM) continue;
                                    const rowOffset = gy2 * GRID_DIM;
                                    
                                    for (let dx = -1; dx <= 1; dx++) {
                                        const gx2 = gx1 + dx;
                                        if (gx2 < 0 || gx2 >= GRID_DIM) continue;
                                        
                                        const gridIndex = gx2 + rowOffset;
                                        const cell = grid[gridIndex];
                                        const cellLen = cell.length;
                                        
                                        for (let k = 0; k < cellLen; k++) {
                                            const j = cell[k]; 
                                            const s2 = segData[j];
                                            
                                            // Call helper function
                                            const { shadow, tint } = this._calculateShadowTint(s1, s2);
                                            shadowSum += shadow;
                                            maxTint = Math.max(maxTint, tint);
                                        }
                                    }
                                }
                                
                                shadows[i] = Math.pow(this.shadowIntensity, shadowSum);
                                tints[i] = 1 - maxTint;

                                const gridIndex = gx1 + gy1 * GRID_DIM;
                                grid[gridIndex].push(i);
                            }
                        } else {
                             shadows.fill(1.0);
                             tints.fill(1.0);
                        }
                    }
                }
                 else {
                    shadows.fill(1.0);
                    tints.fill(1.0);
                }
                
                const dataRange = (maxExtent * 2) + this.lineWidth * 2;
                
                const canvasSize = Math.min(this.canvas.width, this.canvas.height);
                const scale = (canvasSize / dataRange) * this.zoom;
                const pyFigWidthPixels = 480.0;
                const pyPixelsPerData = pyFigWidthPixels / dataRange;
                const baseLineWidthPixels = (this.lineWidth * pyPixelsPerData) * this.zoom;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                if (this.outlineEnabled) {
                    // 3-STEP DRAW (Outline) - Fixes gaps
                    for (const idx of order) {
                        const segInfo = segments[idx];
                        let {r, g, b} = colors[idx];
                        r /= 255; g /= 255; b /= 255;
                        
                        if (renderShadows) {
                            const tintFactor = (0.50 * zNorm[idx] + 0.50 * tints[idx]) / 3;
                            r = r + (1 - r) * tintFactor;
                            g = g + (1 - g) * tintFactor;
                            b = b + (1 - b) * tintFactor;
                            const shadowFactor = 0.20 + 0.25 * zNorm[idx] + 0.55 * shadows[idx];
                            r *= shadowFactor; g *= shadowFactor; b *= shadowFactor;
                        } else {
                            const depthFactor = 0.70 + 0.30 * zNorm[idx];
                            r *= depthFactor; g *= depthFactor; b *= depthFactor;
                        }

                        const color = `rgb(${r*255|0},${g*255|0},${b*255|0})`;
                        const darkenFactor = 0.7;
                        const gapFillerColor = `rgb(${r*255*darkenFactor|0}, ${g*255*darkenFactor|0}, ${b*255*darkenFactor|0})`;

                        // Get coords from rotated array
                        const start = rotated[segInfo.idx1];
                        const end = rotated[segInfo.idx2];
                        const x1 = centerX + start.x * scale; const y1 = centerY - start.y * scale;
                        const x2 = centerX + end.x * scale; const y2 = centerY - end.y * scale;
                        
                        const type = segInfo.type;
                        
                        let widthMultiplier = 1.0;
                        if (type === 'L') {
                            widthMultiplier = 0.5;
                        } else if (type === 'D' || type === 'R') {
                            widthMultiplier = 2.0;
                        }
                        const currentLineWidth = baseLineWidthPixels * widthMultiplier;
                        const totalOutlineWidth = currentLineWidth + (2.0 * 2);

                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.strokeStyle = gapFillerColor;
                        this.ctx.lineWidth = totalOutlineWidth;
                        this.ctx.lineCap = 'butt'; 
                        this.ctx.stroke();

                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = currentLineWidth;
                        this.ctx.lineCap = 'round';
                        this.ctx.stroke();
                    }
                } else {
                    // 1-STEP DRAW (No Outline)
                    for (const idx of order) {
                        const segInfo = segments[idx];
                        let {r, g, b} = colors[idx];
                        r /= 255; g /= 255; b /= 255;
                        
                        if (renderShadows) {
                            const tintFactor = (0.50 * zNorm[idx] + 0.50 * tints[idx]) / 3;
                            r = r + (1 - r) * tintFactor;
                            g = g + (1 - g) * tintFactor;
                            b = b + (1 - b) * tintFactor;
                            const shadowFactor = 0.20 + 0.25 * zNorm[idx] + 0.55 * shadows[idx];
                            r *= shadowFactor; g *= shadowFactor; b *= shadowFactor;
                        } else {
                            const depthFactor = 0.70 + 0.30 * zNorm[idx];
                            r *= depthFactor; g *= depthFactor; b *= depthFactor;
                        }

                        const color = `rgb(${r*255|0},${g*255|0},${b*255|0})`;

                        // Get coords from rotated array
                        const start = rotated[segInfo.idx1];
                        const end = rotated[segInfo.idx2];
                        const x1 = centerX + start.x * scale; const y1 = centerY - start.y * scale;
                        const x2 = centerX + end.x * scale; const y2 = centerY - end.y * scale;
                        
                        const type = segInfo.type;
                        
                        let widthMultiplier = 1.0;
                        if (type === 'L') {
                            widthMultiplier = 0.5;
                        } else if (type === 'D' || type === 'R') {
                            widthMultiplier = 2.0;
                        }
                        const currentLineWidth = baseLineWidthPixels * widthMultiplier;

                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = currentLineWidth;
                        this.ctx.lineCap = 'round';
                        this.ctx.stroke();
                    }
                }
                
                // REMOVED: Render frame number for debugging
                
            } // end of render()

            // Main animation loop
            animate() {
                // REMOVED: The entire 'if (this.isRecording)' block that was here.
                
                const now = performance.now();
                let needsRender = false;

                // 1. Handle inertia/spin
                if (!this.isDragging) {
                    if (Math.abs(this.spinVelocityX) > 0.0001) {
                        const rot = rotationMatrixY(this.spinVelocityX * 0.005);
                        this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix);
                        this.spinVelocityX *= 0.95; // Damping
                        needsRender = true;
                    } else {
                        this.spinVelocityX = 0;
                    }

                    if (Math.abs(this.spinVelocityY) > 0.0001) {
                        const rot = rotationMatrixX(this.spinVelocityY * 0.005);
                        this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix);
                        this.spinVelocityY *= 0.95; // Damping
                        needsRender = true;
                    } else {
                        this.spinVelocityY = 0;
                    }
                }

                // 2. Handle auto-rotate
                if (this.autoRotate && !this.isDragging && this.spinVelocityX === 0 && this.spinVelocityY === 0) {
                    const rot = rotationMatrixY(0.005); // Constant rotation speed
                    this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix);
                    needsRender = true;
                }

                // 3. Handle frame playback
                if (this.isPlaying) {
                    // Check for null
                    if (now - this.lastFrameAdvanceTime > this.animationSpeed && this.currentTrajectoryName) {
                        const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                        if (trajectory && trajectory.frames.length > 0) {
                            let nextFrame = this.currentFrame + 1;

                            // NEW: Check if we are recording and just finished the last frame
                            if (this.isRecording && nextFrame >= trajectory.frames.length) {
                                // We are on the last frame (this.currentFrame) and about to loop.
                                // Stop the recorder *now* to capture the last frame.
                                if (this.recorder && this.recorder.state === "recording") {
                                    this.recorder.stop(); // This triggers 'onstop' which restores state
                                }
                                
                                // We must also stop the playback.
                                this.stopAnimation(); // Sets isPlaying = false
                                
                                // Update status
                                this.saveStatusMessage.textContent = `Finishing...`;
                                
                                // Don't advance the frame, let 'onstop' handle restore
                                needsRender = false; 
                            
                            } else {
                                // Normal playback/recording logic
                                if (nextFrame >= trajectory.frames.length) {
                                    nextFrame = 0;
                                }
                                this.setFrame(nextFrame); // This calls render()
                                this.lastFrameAdvanceTime = now;
                                needsRender = false; // setFrame() already called render()
                                
                                // NEW: Update recording status
                                if (this.isRecording) {
                                    this.saveStatusMessage.textContent = `Recording... ${nextFrame + 1} / ${trajectory.frames.length}`;
                                }
                            }
                        } else {
                            this.stopAnimation();
                        }
                    }
                }

                // 4. Final render if needed
                if (needsRender) {
                    this.render();
                }

                // 5. Loop
                requestAnimationFrame(() => this.animate());
            }
        }

        // ============================================================================
        // MAIN APP & COLAB COMMUNICATION
        // ============================================================================

        // 1. Get config from Python
        const config = window.viewerConfig || { 
            size: [800, 600], 
            color: "plddt", 
            default_shadow: true, 
            default_outline: true,
            default_width: 3.0,
            default_rotate: false,
            hide_controls: false,
            autoplay: false,
            hide_box: false
        };

        // 2. Setup Canvas
        const canvas = document.getElementById('canvas');
        canvas.width = config.size[0];
        canvas.height = config.size[1];
        document.getElementById('viewerColumn').style.width = `${config.size[0]}px`; 

        // 3. Create renderer
        window.renderer = new Pseudo3DRenderer(canvas);
        
        // 4. Setup general controls
        const colorSelect = document.getElementById('colorSelect');
        colorSelect.value = config.color; // Set dropdown value from config
        
        colorSelect.addEventListener('change', (e) => {
            window.renderer.colorMode = e.target.value;
            // --- FIX: Force recalculation of colors when mode changes ---
            window.renderer.colors = window.renderer._calculateSegmentColors();
            window.renderer.render();
        });
        
        // Setup shadowEnabledCheckbox
        const shadowEnabledCheckbox = document.getElementById('shadowEnabledCheckbox'); 
        shadowEnabledCheckbox.checked = window.renderer.shadowEnabled; // Set default from renderer
        
        // Setup outlineEnabledCheckbox
        const outlineEnabledCheckbox = document.getElementById('outlineEnabledCheckbox'); 
        outlineEnabledCheckbox.checked = window.renderer.outlineEnabled; // Set default from renderer

        // 5. Setup animation and trajectory controls
        const controlsContainer = document.getElementById('controlsContainer');
        const playButton = document.getElementById('playButton');
        const frameSlider = document.getElementById('frameSlider');
        const frameCounter = document.getElementById('frameCounter');
        const trajectorySelect = document.getElementById('trajectorySelect');
        const speedSelect = document.getElementById('speedSelect');
        const rotationCheckbox = document.getElementById('rotationCheckbox');
        const lineWidthSlider = document.getElementById('lineWidthSlider');
        
        // NEW: Get save button and status
        const saveAnimationButton = document.getElementById('saveAnimationButton');
        const saveStatusMessage = document.getElementById('saveStatusMessage');
        
        // Set defaults for width and rotate
        lineWidthSlider.value = window.renderer.lineWidth;
        rotationCheckbox.checked = window.renderer.autoRotate;

        // Pass ALL controls to the renderer
        window.renderer.setUIControls(
            controlsContainer, playButton, 
            frameSlider, frameCounter, trajectorySelect, 
            speedSelect, rotationCheckbox, lineWidthSlider,
            shadowEnabledCheckbox, outlineEnabledCheckbox,
            saveAnimationButton, saveStatusMessage // NEW
        );

        // Handle new UI config options
        if (config.hide_controls) {
            document.getElementById('rightPanelContainer').style.display = 'none';
            // controlsContainer is handled by updateUIControls
        }

        // Handle hide_box
        if (config.hide_box) {
            document.getElementById('canvasContainer').style.border = 'none';
            document.getElementById('canvasContainer').style.boxShadow = 'none';
            document.getElementById('canvasContainer').style.background = 'transparent';
            document.getElementById('canvas').style.background = 'transparent';
            
            window.renderer.setClearColor(true); 
        }

        // 6. Add function for Python to call (for new frames)
        window.handlePythonUpdate = (jsonData, trajectoryName) => {
            try {
                const data = JSON.parse(jsonData);
                // Pass name to addFrame
                window.renderer.addFrame(data, trajectoryName);
            } catch (e) {
                console.error("Failed to parse JSON from Python:", e);
            }
        };

        // 7. Add function for Python to start a new trajectory
        window.handlePythonNewTrajectory = (name) => {
            window.renderer.addTrajectory(name);
        };

        // 8. Add function for Python to clear everything
        window.handlePythonClearAll = () => {
            window.renderer.clearAllTrajectories();
        };


        // 9. Load initial data (NEW LOGIC)
        let isStaticViewer = false;

        if (window.staticTrajectoryData && window.staticTrajectoryData.length > 0) {
            // === STATIC MODE (from show()) ===
            isStaticViewer = true;
            try {
                // Loop over all trajectories
                for (const traj of window.staticTrajectoryData) {
                    if (traj.name && traj.frames && traj.frames.length > 0) {
                        // Add the first frame, which creates the trajectory
                        window.renderer.addFrame(traj.frames[0], traj.name);
                        
                        // Add any remaining frames
                        for (let i = 1; i < traj.frames.length; i++) {
                            window.renderer.addFrame(traj.frames[i], traj.name);
                        }
                    }
                }
                // Set view to the first frame of the first trajectory
                if (window.staticTrajectoryData.length > 0) {
                    window.renderer.currentTrajectoryName = window.staticTrajectoryData[0].name;
                    window.renderer.trajectorySelect.value = window.staticTrajectoryData[0].name;
                    window.renderer.setFrame(0);
                }
            } catch (error) {
                console.error("Error loading static trajectory data:", error);
                window.renderer.setFrame(-1); // Start empty on error
            }
            
        } else if (window.proteinData && window.proteinData.coords && window.proteinData.coords.length > 0) {
            // === HYBRID MODE (first frame) ===
            try {
                // Load the single, statically-injected frame into "0"
                window.renderer.addFrame(window.proteinData, "0"); 
            } catch (error) {
                console.error("Error loading initial data:", error);
                window.renderer.setFrame(-1);
            }
        } else {
            // === EMPTY DYNAMIC MODE ===
            // No-initial data, start with an empty canvas.
            window.renderer.setFrame(-1);
        }

        // 10. Add postMessage listener (MODIFIED)
        // Only listen for messages if this is NOT a static viewer
        if (!isStaticViewer) {
            window.addEventListener('message', (event) => {
                if (event.data && event.data.type) {
                    if (event.data.type === 'py2DmolUpdate') {
                        try {
                            // Pass trajectoryName from message
                            window.handlePythonUpdate(
                                JSON.stringify(event.data.payload),
                                event.data.trajectoryName 
                            );
                        } catch (e) {
                             console.error("Failed to handle postMessage (update):", e, event.data.payload);
                        }
                    } else if (event.data.type === 'py2DmolNewTrajectory') {
                        try {
                            window.handlePythonNewTrajectory(event.data.name);
                        } catch (e) {
                             console.error("Failed to handle postMessage (new trajectory):", e, event.data.name);
                        }
                    } else if (event.data.type === 'py2DmolClearAll') {
                        try {
                            window.handlePythonClearAll();
                        } catch (e) {
                             console.error("Failed to handle postMessage (clear all):", e);
                        }
                    }
                }
            });
        }

        // 11. Start the main animation loop
        window.renderer.animate();
        
        // 12. Notify the parent window that the iframe is loaded and ready (MODIFIED)
        // Only notify if not static (i.e., we are a dynamic/hybrid viewer)
        if (window.parent && !isStaticViewer) {
            window.parent.postMessage({ 
                type: "py2dmol_ready", 
                viewer_id: config.viewer_id 
            }, "*");
        }

    </script>
</body>
</html>