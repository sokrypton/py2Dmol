<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protein Pseudo-3D Viewer</title>
    <style>
        * { box-sizing: border-box; }
        /* Remove all margins for a clean embed */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #fff;
            text-align: left; /* Aligns the container to the left */
        }
        #mainContainer {
            display: inline-block; /* Makes the container wrap content */
            text-align: left;
        }
        #canvasContainer {
            /* This is the stylized "box" */
            display: inline-block;
            position: relative;
            border: 1px solid #ddd;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        #canvas {
            background: #ffffff;
            cursor: grab;
            display: block;
        }
        #canvas:active {
            cursor: grabbing;
        }

        /* Style for the floating dropdown */
        #colorSelect {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            font-size: 12px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.8);
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            cursor: pointer;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%2Mxmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23444444%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.6-3.6%205.4-7.8%205.4-12.8%200-5-1.8-9.2-5.4-12.8z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 8px top 50%;
            background-size: 8px auto;
            padding-right: 28px;
        }
        #colorSelect:focus {
            outline: none;
            border-color: #007bff;
        }

        /* NEW: Style for options container */
        #optionsContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 10;
            font-size: 12px;
            color: #333;
            background-color: rgba(255, 255, 255, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
            display: flex;
            flex-direction: column; /* Stack controls vertically */
            align-items: flex-start; /* Align to the left */
            gap: 4px;
        }
        .toggle-item { /* NEW: Wrapper for label/input pairs */
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .toggle-item label { cursor: pointer; white-space: nowrap; }
        .toggle-item input[type="checkbox"] { cursor: pointer; margin: 0; }
        .toggle-item input[type="range"] {
            cursor: pointer;
            width: 80px; /* Short slider for linewidth */
        }


        /* Animation Controls Container */
        #controlsContainer {
            /* MODIFIED: Use flex for better alignment */
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            padding: 10px 10px 0 10px;
            text-align: left;
            width: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12px;
        }
        /* NEW: Trajectory Controls Container */
        #trajectoryContainer {
            padding: 5px 10px 10px 10px; /* Top padding 5px */
            width: 100%;
            font-size: 12px;
        }
        .controlButton { /* NEW: Shared button style */
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background: #f0f0f0;
            cursor: pointer;
            min-width: 60px;
            font-size: 12px;
            vertical-align: middle;
            margin-right: 5px;
            flex-shrink: 0; /* Don't let buttons shrink */
        }
        .controlButton:disabled {
            cursor: not-allowed;
            background: #eee;
            color: #999;
        }
        #frameSlider {
            /* MODIFIED: Let it flex */
            flex-grow: 1; 
            width: auto; /* Remove fixed/js width */
            margin: 0 10px;
            vertical-align: middle;
        }
        #frameCounter {
            color: #333;
            vertical-align: middle;
            min-width: 80px;
            display: inline-block;
            flex-shrink: 0; /* Don't let it shrink */
        }
        #speedSelect { /* NEW */
            font-size: 12px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            vertical-align: middle;
            margin-left: 10px;
            flex-shrink: 0; /* Don't let it shrink */
        }
        /* NEW: Trajectory Select */
        #trajectorySelect {
            font-size: 12px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            vertical-align: middle;
            margin-left: 5px;
        }
        #trajectorySelect:disabled {
             cursor: not-allowed;
            background: #eee;
        }
        #trajectoryLabel {
            vertical-align: middle;
        }

    </style>
</head>
<body>
    <!-- Main container to hold viewer and controls -->
    <div id="mainContainer">
        <!-- The canvas and dropdown are now siblings in the container -->
        <div id="canvasContainer">
            <canvas id="canvas"></canvas>
            <!-- MODIFIED: Options container -->
            <div id="optionsContainer">
                <div class="toggle-item">
                    <input type="checkbox" id="shadowCheckbox" checked>
                    <label for="shadowCheckbox">Shadow</label>
                </div>
                <!-- HTML TYPO FIX: class.toggle-item -> class="toggle-item" -->
                <div class="toggle-item"> 
                    <input type="checkbox" id="rotationCheckbox">
                    <label for="rotationCheckbox">Rotate</label>
                </div>
                <div class="toggle-item">
                    <label for="lineWidthSlider">Line:</label>
                    <input type="range" id="lineWidthSlider" min="1" max="10" value="3" step="0.5">
                </div>
            </div>
            <!-- Floating Dropdown Menu -->
            <select id="colorSelect">
                <option value="plddt">pLDDT</option>
                <option value="rainbow">Rainbow</option>
                <option value="chain">Chain</option>
            </select>
        </div>

        <!-- Animation Controls -->
        <div id="controlsContainer">
            <button id="playButton" class="controlButton">Play</button>
            <input type="range" id="frameSlider" min="0" max="0" value="0">
            <span id="frameCounter">Frame: 0 / 0</span>
            <!-- NEW: Speed Select -->
            <select id="speedSelect">
                <option value="100">1x</option>
                <option value="50">2x</option>
                <option value="25">4x</option>
            </select>
        </div>
        <!-- NEW Trajectory Controls -->
        <div id="trajectoryContainer">
            <span id="trajectoryLabel">Trajectory:</span>
            <select id="trajectorySelect">
                <option value="default">0</option>
            </select>
            <!-- REMOVED Save Video Button -->
        </div>
    </div>

    <!--
      This single point will be replaced by the Python script
      with viewer config AND initial data.
    -->
    <!-- DATA_INJECTION_POINT -->

    <script>
        // ============================================================================
        // VECTOR MATH (Unchanged)
        // ============================================================================
        class Vec3 {
            constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
            add(v) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }
            sub(v) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }
            mul(s) { return new Vec3(this.x * s, this.y * s, this.z * s); }
            dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z; }
            length() { return Math.sqrt(this.dot(this)); }
            distanceTo(v) { return this.sub(v).length(); }
            normalize() { 
                const len = this.length(); 
                return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 1); 
            }
        }
        function rotationMatrixX(angle) { const c = Math.cos(angle), s = Math.sin(angle); return [[1,0,0], [0,c,-s], [0,s,c]]; }
        function rotationMatrixY(angle) { const c = Math.cos(angle), s = Math.sin(angle); return [[c,0,s], [0,1,0], [-s,0,c]]; }
        function multiplyMatrices(a, b) { const r = [[0,0,0],[0,0,0],[0,0,0]]; for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) for (let k = 0; k < 3; k++) r[i][j] += a[i][k] * b[k][j]; return r; }
        function applyMatrix(m, v) { return new Vec3(m[0][0]*v.x + m[0][1]*v.y + m[0][2]*v.z, m[1][0]*v.x + m[1][1]*v.y + m[1][2]*v.z, m[2][0]*v.x + m[2][1]*v.y + m[2][2]*v.z); }
        function sigmoid(x) { return 1 / (1 + Math.exp(-x)); }

        // ============================================================================
        // COLOR UTILITIES (Unchanged)
        // ============================================================================
        const pymolColors = ["#33ff33","#00ffff","#ff33cc","#ffff00","#ff9999","#e5e5e5","#7f7fff","#ff7f00","#7fff7f","#199999","#ff007f","#ffdd5e","#8c3f99","#b2b2b2","#007fff","#c4b200","#8cb266","#00bfbf","#b27f7f","#fcd1a5","#ff7f7f","#ffbfdd","#7fffff","#ffff7f","#00ff7f","#337fcc","#d8337f","#bfff3f","#ff7fff","#d8d8ff","#3fffbf","#b78c4c","#339933","#66b2b2","#ba8c84","#84bf00","#b24c66","#7f7f7f","#3f3fa5","#a5512b"];
        function hexToRgb(hex) { if (!hex || typeof hex !== 'string') { return {r: 128, g: 128, b: 128}; } const r = parseInt(hex.slice(1,3), 16); const g = parseInt(hex.slice(3,5), 16); const b = parseInt(hex.slice(5,7), 16); return {r, g, b}; }
        function hsvToRgb(h, s, v) { const c = v * s; const x = c * (1 - Math.abs((h / 60) % 2 - 1)); const m = v - c; let r, g, b; if (h < 60) { r = c; g = x; b = 0; } else if (h < 120) { r = x; g = c; b = 0; } else if (h < 180) { r = 0; g = c; b = x; } else if (h < 240) { r = 0; g = x; b = c; } else if (h < 300) { r = x; g = 0; b = c; } else { r = c; g = 0; b = x; } return { r: Math.round((r + m) * 255), g: Math.round((g + m) * 255), b: Math.round((b + m) * 255) }; }
        function getRainbowColor(value, min, max) { if (max - min < 1e-6) return hsvToRgb(0, 1.0, 1.0); let normalized = (value - min) / (max - min); normalized = Math.max(0, Math.min(1, normalized)); const hue = 240 * normalized; return hsvToRgb(hue, 1.0, 1.0); }
        function getPlddtColor(plddt) { return getRainbowColor(plddt, 50, 90); }
        function getChainColor(chainIndex) { if (chainIndex < 0) chainIndex = 0; return hexToRgb(pymolColors[chainIndex % pymolColors.length]); }

        // ============================================================================
        // DEMO STRUCTURE GENERATOR (Unchanged)
        // ============================================================================
        function generateProteinCurve(n) { const coords = []; const plddts = []; const chains = []; const atomTypes = []; let angle = 0, z = 0; const numProtein = n - 10; for (let i = 0; i < n; i++) { const t = i / n; chains.push(i < n / 2 ? 'A' : 'B'); if (i >= numProtein) { atomTypes.push('L'); plddts.push(75.0); const protEnd = coords[numProtein - 1] || new Vec3(0,0,0); const lt = (i - numProtein) / 10.0; const lx = protEnd.x + 5 + lt * 5 * Math.cos(lt * 20); const ly = protEnd.y + 5 + lt * 5 * Math.sin(lt * 20); const lz = protEnd.z - 3 + lt * 3; coords.push(new Vec3(lx, ly, lz)); } else { atomTypes.push('P'); plddts.push((Math.sin(t * Math.PI * 6) * 0.5 + 0.5) * 50 + 40); const freq = 2 + Math.sin(t * Math.PI * 2) * 1.5; angle += 0.3 * freq; const radius = 15 + 10 * Math.sin(t * Math.PI * 4); const x = radius * Math.cos(angle); const y = radius * Math.sin(angle); z += 0.5 + 0.3 * Math.sin(t * Math.PI * 8); coords.push(new Vec3(x, y, z)); } } return {coords, plddts, chains, atomTypes}; }

        // ============================================================================
        // PSEUDO-3D RENDERER (Refactored)
        // ============================================================================
        class Pseudo3DRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                
                // Current render state
                this.coords = [];
                this.plddts = [];
                this.chains = [];
                this.atomTypes = [];
                
                // Viewer state
                this.colorMode = 'plddt';
                this.rotationMatrix = [[1,0,0],[0,1,0],[0,0,1]];
                this.zoom = 1.0;
                this.lineWidth = 3.0;
                this.shadowIntensity = 0.95;
                this.shadowEnabled = true;
                
                // Performance
                this.chainRainbowScales = {};

                // --- REFACTORED: Animation & State ---
                this.trajectoriesData = { "default": { maxExtent: 0, frames: [], globalCenterSum: new Vec3(0,0,0), totalAtoms: 0 } };
                this.currentTrajectoryName = "default";
                this.currentFrame = -1;
                
                // Playback
                this.isPlaying = false;
                this.animationSpeed = 100; // ms per frame
                this.lastFrameAdvanceTime = 0;
                
                // Interaction
                this.isDragging = false;
                this.autoRotate = false;
                
                // Inertia
                this.spinVelocityX = 0;
                this.spinVelocityY = 0;
                this.lastDragTime = 0;
                this.lastDragX = 0;
                this.lastDragY = 0;
                
                // Track slider interaction
                this.isSliderDragging = false;

                // UI elements
                this.playButton = null;
                // REMOVED: this.saveVideoButton = null;
                this.frameSlider = null;
                this.frameCounter = null;
                this.trajectorySelect = null;
                this.controlsContainer = null;
                this.speedSelect = null;
                this.rotationCheckbox = null;
                this.lineWidthSlider = null;

                // REMOVED: Video recording properties
                // this.mediaRecorder = null;
                // this.recordedChunks = [];
                // this.isRecording = false;

                this.setupInteraction();
            }

            setupInteraction() {
                // --- REFACTORED: Added inertia logic ---
                this.canvas.addEventListener('mousedown', (e) => {
                    // Only start dragging if we clicked directly on the canvas
                    if (e.target !== this.canvas) return;
                    
                    this.isDragging = true;
                    this.spinVelocityX = 0;
                    this.spinVelocityY = 0;
                    this.lastDragX = e.clientX;
                    this.lastDragY = e.clientY;
                    this.lastDragTime = performance.now();
                    if (this.autoRotate) {
                        this.autoRotate = false;
                        if (this.rotationCheckbox) this.rotationCheckbox.checked = false;
                    }
                });
                
                window.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return; // REMOVED: isRecording check
                    
                    // SLIDER FIX: Clear isDragging and stop if over a control element
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON') {
                        this.isDragging = false;
                        return;
                    }
                    
                    const now = performance.now();
                    const timeDelta = now - this.lastDragTime;

                    const dx = e.clientX - this.lastDragX;
                    const dy = e.clientY - this.lastDragY;
                    
                    if (dy !== 0) { const rot = rotationMatrixX(dy * 0.01); this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix); }
                    if (dx !== 0) { const rot = rotationMatrixY(dx * 0.01); this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix); }

                    // Store velocity for inertia
                    if (timeDelta > 0) {
                        // Weighted average to smooth out jerky movements
                        const smoothing = 0.5;
                        this.spinVelocityX = (this.spinVelocityX * (1-smoothing)) + ((dx / timeDelta * 20) * smoothing);
                        this.spinVelocityY = (this.spinVelocityY * (1-smoothing)) + ((dy / timeDelta * 20) * smoothing);
                    }

                    this.lastDragX = e.clientX;
                    this.lastDragY = e.clientY;
                    this.lastDragTime = now;
                    
                    this.render(); // Render immediately while dragging
                });
                
                window.addEventListener('mouseup', () => {
                    this.isDragging = false;
                    const now = performance.now();
                    const timeDelta = now - this.lastDragTime;
                    
                    if (timeDelta > 100) { // If drag was too slow, or just a click
                        this.spinVelocityX = 0;
                        this.spinVelocityY = 0;
                    }
                    // Else, the velocity from the last mousemove is used by the animate loop
                });

                this.canvas.addEventListener('wheel', (e) => {
                    // REMOVED: isRecording check
                    e.preventDefault();
                    this.zoom *= (1 - e.deltaY * 0.001);
                    this.zoom = Math.max(0.1, Math.min(5, this.zoom));
                    this.render();
                }, { passive: false });
            }

            // Set UI controls from main script
            setUIControls(controlsContainer, playButton, frameSlider, frameCounter, trajectorySelect, speedSelect, rotationCheckbox, lineWidthSlider) { // MODIFIED: removed saveVideoButton
                this.controlsContainer = controlsContainer;
                this.playButton = playButton;
                // REMOVED: this.saveVideoButton = saveVideoButton;
                this.frameSlider = frameSlider;
                this.frameCounter = frameCounter;
                this.trajectorySelect = trajectorySelect;
                this.speedSelect = speedSelect;
                this.rotationCheckbox = rotationCheckbox;
                this.lineWidthSlider = lineWidthSlider;
                
                this.lineWidth = parseFloat(this.lineWidthSlider.value);

                // --- BIND ALL EVENT LISTENERS HERE ---
                this.playButton.addEventListener('click', () => {
                    this.togglePlay();
                });

                this.trajectorySelect.addEventListener('change', () => {
                    this.stopAnimation();
                    this.currentTrajectoryName = this.trajectorySelect.value;
                    this.setFrame(0);
                });

                this.speedSelect.addEventListener('change', (e) => {
                    this.animationSpeed = parseInt(e.target.value);
                });

                this.rotationCheckbox.addEventListener('change', (e) => {
                    this.autoRotate = e.target.checked;
                    // Stop inertia if user clicks auto-rotate
                    this.spinVelocityX = 0;
                    this.spinVelocityY = 0;
                });

                this.lineWidthSlider.addEventListener('input', (e) => {
                    this.lineWidth = parseFloat(e.target.value);
                    if (!this.isPlaying) { // REMOVED: isRecording check
                        this.render();
                    }
                });

                // --- SLIDER FIX: Prevent canvas drag from interfering with slider ---
                const handleSliderChange = (e) => {
                    this.stopAnimation();
                    this.setFrame(parseInt(e.target.value));
                };

                // Track when user is interacting with slider
                this.frameSlider.addEventListener('mousedown', (e) => {
                    this.isDragging = false;
                    this.isSliderDragging = true;
                    e.stopPropagation();
                });
                
                this.frameSlider.addEventListener('mouseup', (e) => {
                    this.isSliderDragging = false;
                });
                
                // Also clear on window mouseup in case user releases outside slider
                window.addEventListener('mouseup', () => {
                    this.isSliderDragging = false;
                });
                
                this.frameSlider.addEventListener('input', handleSliderChange);
                this.frameSlider.addEventListener('change', handleSliderChange);
                
                // Also prevent canvas drag when interacting with other controls
                const allControls = [this.playButton, this.trajectorySelect, this.speedSelect, 
                                     this.rotationCheckbox, this.lineWidthSlider];
                allControls.forEach(control => {
                    if (control) {
                        control.addEventListener('mousedown', (e) => {
                            this.isDragging = false;
                            e.stopPropagation();
                        });
                    }
                });
            }

            // Add a new trajectory
            addTrajectory(name) {
                this.stopAnimation();
                this.trajectoriesData[name] = { maxExtent: 0, frames: [], globalCenterSum: new Vec3(0,0,0), totalAtoms: 0 };
                this.currentTrajectoryName = name;
                this.currentFrame = -1;

                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                this.trajectorySelect.appendChild(option);
                this.trajectorySelect.value = name;

                this.updateUIControls();
            }

            // Add a frame (data is raw parsed JSON)
            addFrame(data) {
                if (!this.currentTrajectoryName) {
                    this.currentTrajectoryName = "default";
                }
                if (!this.trajectoriesData[this.currentTrajectoryName]) {
                    this.trajectoriesData[this.currentTrajectoryName] = { maxExtent: 0, frames: [], globalCenterSum: new Vec3(0,0,0), totalAtoms: 0 };
                }

                const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                trajectory.frames.push(data);

                // --- Update global center sum and count ---
                let frameSum = new Vec3(0,0,0);
                let frameAtoms = 0;
                if (data && data.coords) {
                    frameAtoms = data.coords.length;
                    for (const c of data.coords) {
                        frameSum = frameSum.add(new Vec3(c[0], c[1], c[2]));
                    }
                    trajectory.globalCenterSum = trajectory.globalCenterSum.add(frameSum);
                    trajectory.totalAtoms += frameAtoms;
                }
                
                const globalCenter = (trajectory.totalAtoms > 0) ? trajectory.globalCenterSum.mul(1 / trajectory.totalAtoms) : new Vec3(0,0,0);

                // --- Recalculate maxExtent for *all* frames using the *new* global center ---
                let maxDistSq = 0;
                for (const frame of trajectory.frames) {
                    if (frame && frame.coords) {
                        for (const c of frame.coords) {
                            const coordVec = new Vec3(c[0], c[1], c[2]);
                            const centeredCoord = coordVec.sub(globalCenter);
                            const distSq = centeredCoord.dot(centeredCoord);
                            if (distSq > maxDistSq) maxDistSq = distSq;
                        }
                    }
                }
                trajectory.maxExtent = Math.sqrt(maxDistSq);

                if (!this.isPlaying) { // REMOVED: isRecording check
                    this.setFrame(trajectory.frames.length - 1);
                }
                this.updateUIControls();
            }

            // Set the current frame and render it
            setFrame(frameIndex) {
                frameIndex = parseInt(frameIndex);
                if (!this.currentTrajectoryName) return;

                const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                if (!trajectory || frameIndex < 0 || frameIndex >= trajectory.frames.length) {
                    this.currentFrame = -1;
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.updateUIControls();
                    return;
                }

                this.currentFrame = frameIndex;
                const data = trajectory.frames[frameIndex];
                this._loadDataIntoRenderer(data); // This calls render()
                this.updateUIControls(); // Update slider value
            }

            // Update UI element states (e.g., disabled)
            setUIEnabled(enabled) {
                 this.playButton.disabled = !enabled;
                 // REMOVED: this.saveVideoButton.disabled = !enabled;
                 this.frameSlider.disabled = !enabled;
                 this.trajectorySelect.disabled = !enabled;
                 this.speedSelect.disabled = !enabled;
                 this.rotationCheckbox.disabled = !enabled;
                 this.lineWidthSlider.disabled = !enabled;
                 this.canvas.style.cursor = enabled ? 'grab' : 'wait';
            }

            // Update the text/slider values
            updateUIControls() {
                if (!this.playButton) return;

                const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                const total = trajectory ? trajectory.frames.length : 0;
                const current = Math.max(0, this.currentFrame) + 1;

                if (total <= 1) { // MODIFIED: Simplified show/hide
                    this.controlsContainer.style.display = 'none';
                } else {
                    this.controlsContainer.style.display = 'flex';
                }

                this.frameSlider.max = Math.max(0, total - 1);
                
                // CRITICAL FIX: Don't update slider value while user is dragging it!
                if (!this.isSliderDragging) {
                    this.frameSlider.value = this.currentFrame;
                }
                
                this.frameCounter.textContent = `Frame: ${total > 0 ? current : 0} / ${total}`;

                // MODIFIED: Simplified text logic
                this.playButton.textContent = this.isPlaying ? 'Pause' : 'Play';
            }

            // Toggle play/pause
            togglePlay() {
                // REMOVED: isRecording check
                if (this.isPlaying) {
                    this.stopAnimation();
                } else {
                    this.startAnimation();
                }
            }

            // --- REFACTORED: Start playback ---
            startAnimation() {
                // REMOVED: isRecording check
                const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                if (!trajectory || trajectory.frames.length < 2) return;

                this.isPlaying = true;
                this.lastFrameAdvanceTime = performance.now(); // Set start time
                this.updateUIControls();
            }

            // --- REFACTORED: Stop playback ---
            stopAnimation() {
                this.isPlaying = false;
                this.updateUIControls();
            }

            // REMOVED: saveAnimationAsVideo method

            // Load data into renderer
            _loadDataIntoRenderer(data) {
                try {
                    if (data && data.coords && data.coords.length > 0) {
                        const coords = data.coords.map(c => new Vec3(c[0], c[1], c[2]));
                        const plddts = data.plddts || [];
                        const chains = data.chains || [];
                        const atomTypes = data.atom_types || [];
                        this.setCoords(coords, plddts, chains, atomTypes);
                    }
                } catch (e) {
                    console.error("Failed to load data into renderer:", e);
                }
                this.render();
            }

            // Set current coordinates
            setCoords(coords, plddts = [], chains = [], atomTypes = []) {
                this.coords = coords;
                this.plddts = plddts;
                this.chains = chains;
                this.atomTypes = atomTypes;

                if (this.plddts.length !== this.coords.length) { this.plddts = Array(this.coords.length).fill(50.0); }
                if (this.chains.length !== this.coords.length) { this.chains = Array(this.coords.length).fill('A'); }
                if (this.atomTypes.length !== this.coords.length) { this.atomTypes = Array(this.coords.length).fill('P'); }

                // PERFORMANCE: Auto-disable shadows for large structures (>1000 atoms)
                if (this.coords.length > 1000 && this.shadowEnabled) {
                    this.shadowEnabled = false;
                    if (this.shadowCheckbox) {
                        this.shadowCheckbox.checked = false;
                    }
                }

                this.chainRainbowScales = {};
                for (let i = 0; i < this.atomTypes.length; i++) {
                    const type = this.atomTypes[i];
                    // Include protein (P), DNA (D), and RNA (R) in rainbow coloring
                    if (type === 'P' || type === 'D' || type === 'R') {
                        const chainId = this.chains[i] || 'A';
                        if (!this.chainRainbowScales[chainId]) { 
                            this.chainRainbowScales[chainId] = { min: Infinity, max: -Infinity }; 
                        }
                        const colorIndex = this.coords.length - 1 - i;
                        const scale = this.chainRainbowScales[chainId];
                        scale.min = Math.min(scale.min, colorIndex);
                        scale.max = Math.max(scale.max, colorIndex);
                    }
                }
            }

            // --- RENDER (Core drawing logic) ---
            render() {
                const startTime = performance.now();
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                if (this.coords.length === 0) return;

                const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                const globalCenter = (trajectory && trajectory.totalAtoms > 0) ? trajectory.globalCenterSum.mul(1 / trajectory.totalAtoms) : new Vec3(0,0,0);

                const rotated = this.coords.map(v => applyMatrix(this.rotationMatrix, v.sub(globalCenter)));
                const segments = [];
                const proteinChainbreak = 5.0;
                const nucleicChainbreak = 7.5; // DNA/RNA C4'-C4' distance
                const ligandBondCutoff = 2.0;
                let firstPolymerIndex = -1;
                let lastPolymerIndex = -1;
                const ligandIndices = [];

                // Helper function to check if atom is polymer (protein or nucleic)
                const isPolymer = (type) => (type === 'P' || type === 'D' || type === 'R');
                const getChainbreakDist = (type1, type2) => {
                    if ((type1 === 'D' || type1 === 'R') && (type2 === 'D' || type2 === 'R')) {
                        return nucleicChainbreak;
                    }
                    return proteinChainbreak;
                };

                for (let i = 0; i < rotated.length; i++) {
                    const type = this.atomTypes[i];
                    
                    if (type === 'L') {
                        ligandIndices.push(i);
                        continue;
                    }
                    
                    if (isPolymer(type)) {
                        if (firstPolymerIndex === -1) { firstPolymerIndex = i; }
                        lastPolymerIndex = i;
                        
                        if (i < rotated.length - 1) {
                            const type1 = this.atomTypes[i];
                            const type2 = this.atomTypes[i+1];
                            
                            // Check if both are polymer atoms of compatible types
                            if (isPolymer(type1) && isPolymer(type2)) {
                                // Can connect: P-P, D-D, R-R (but not P-D, P-R, D-R)
                                const samePolymerType = (type1 === type2) || 
                                    ((type1 === 'D' || type1 === 'R') && (type2 === 'D' || type2 === 'R'));
                                
                                if (samePolymerType && this.chains[i] === this.chains[i+1]) {
                                    const start = rotated[i];
                                    const end = rotated[i+1];
                                    const dist = start.distanceTo(end);
                                    const chainbreakDist = getChainbreakDist(type1, type2);
                                    
                                    if (dist < chainbreakDist) {
                                        segments.push({ 
                                            start, 
                                            end, 
                                            mid: start.add(end).mul(0.5), 
                                            length: dist, 
                                            colorIndex: rotated.length - 1 - i, 
                                            origIndex: i, 
                                            chainId: this.chains[i] || 'A' 
                                        });
                                    }
                                }
                            }
                        }
                    }
                }

                // Close loop for polymer if first and last are same chain and close enough
                if (firstPolymerIndex !== -1 && lastPolymerIndex !== -1 && firstPolymerIndex !== lastPolymerIndex) {
                    const firstChainId = this.chains[firstPolymerIndex] || 'A';
                    const lastChainId = this.chains[lastPolymerIndex] || 'A';
                    const type1 = this.atomTypes[firstPolymerIndex];
                    const type2 = this.atomTypes[lastPolymerIndex];
                    
                    if (firstChainId === lastChainId && isPolymer(type1) && isPolymer(type2)) {
                        const samePolymerType = (type1 === type2) || 
                            ((type1 === 'D' || type1 === 'R') && (type2 === 'D' || type2 === 'R'));
                        
                        if (samePolymerType) {
                            const start = rotated[firstPolymerIndex];
                            const end = rotated[lastPolymerIndex];
                            const dist = start.distanceTo(end);
                            const chainbreakDist = getChainbreakDist(type1, type2);
                            
                            if (dist < chainbreakDist) {
                                segments.push({ 
                                    start, 
                                    end, 
                                    mid: start.add(end).mul(0.5), 
                                    length: dist, 
                                    colorIndex: this.chainRainbowScales[firstChainId]?.min || 0, 
                                    origIndex: firstPolymerIndex, 
                                    chainId: firstChainId 
                                });
                            }
                        }
                    }
                }

                for (let i = 0; i < ligandIndices.length; i++) {
                    for (let j = i + 1; j < ligandIndices.length; j++) {
                        const idx1 = ligandIndices[i];
                        const idx2 = ligandIndices[j];
                        const start = rotated[idx1];
                        const end = rotated[idx2];
                        const dist = start.distanceTo(end);
                        if (dist < ligandBondCutoff) {
                             segments.push({ start, end, mid: start.add(end).mul(0.5), length: dist, colorIndex: 0, origIndex: idx1, chainId: this.chains[idx1] || 'A' });
                        }
                    }
                }

                if (segments.length === 0) return;

                // PERFORMANCE: Pre-compute unique chains once for chain coloring mode
                const uniqueChains = (this.colorMode === 'chain' && this.chains.length > 0) 
                    ? [...new Set(this.chains)] 
                    : [];

                const grey = {r: 128, g: 128, b: 128};
                const colors = segments.map(seg => {
                    const i = seg.origIndex;
                    const type = this.atomTypes[i];
                    if (type === 'L') {
                        if (this.colorMode === 'plddt') {
                            const plddt1 = (this.plddts[i] !== null && this.plddts[i] !== undefined) ? this.plddts[i] : 50;
                            return getPlddtColor(plddt1);
                        }
                        return grey;
                    }
                    if (this.colorMode === 'plddt') {
                        const plddt1 = (this.plddts[i] !== null && this.plddts[i] !== undefined) ? this.plddts[i] : 50;
                        const plddt2_idx = (seg.origIndex + 1 < this.coords.length) ? seg.origIndex + 1 : seg.origIndex;
                        const plddt2 = (this.plddts[plddt2_idx] !== null && this.plddts[plddt2_idx] !== undefined) ? this.plddts[plddt2_idx] : 50;
                        return getPlddtColor((plddt1 + plddt2) / 2);
                    }
                    else if (this.colorMode === 'chain') {
                        if (uniqueChains.length === 0) return getChainColor(0);
                        const chainId = this.chains[i] || 'A';
                        const chainIndex = uniqueChains.indexOf(chainId);
                        return getChainColor(chainIndex >= 0 ? chainIndex : 0);
                    }
                    else {
                        const scale = this.chainRainbowScales[seg.chainId];
                        if (scale) { return getRainbowColor(seg.colorIndex, scale.min, scale.max); }
                        else { return grey; }
                    }
                });

                const zValues = segments.map(s => (s.start.z + s.end.z) / 2);
                const zMin = Math.min(...zValues);
                const zMax = Math.max(...zValues);
                const zNorm = zValues.map(z => zMax - zMin > 1e-6 ? (z - zMin) / (zMax - zMin) : 0);
                const n = segments.length;
                
                // PERFORMANCE: Use fast lighting for large structures (>1000 atoms)
                const useFastLighting = (this.coords.length > 1000) || !this.shadowEnabled;
                
                const shadows = new Float32Array(n);
                const tints = new Float32Array(n);
                const lighting = new Float32Array(n);  // For directional lighting

                if (useFastLighting) {
                    // FAST PATH: Directional lighting (O(N))
                    // Light direction: from upper-right-front
                    const lightDir = new Vec3(0.5, 0.3, 1.0).normalize();
                    
                    for (let i = 0; i < n; i++) {
                        const seg = segments[i];
                        // Calculate segment direction
                        const segDir = seg.end.sub(seg.start).normalize();
                        
                        // Simple diffuse lighting based on segment orientation
                        const diffuse = Math.abs(segDir.dot(lightDir));
                        lighting[i] = 0.5 + 0.5 * diffuse;  // Range: 0.5 to 1.0
                    }
                    
                    shadows.fill(1.0);
                    tints.fill(1.0);
                } else {
                    // QUALITY PATH: Complex shadow calculations (O(N²))
                    for (let i = 0; i < n; i++) {
                        let shadowSum = 0; let maxTint = 0;
                        const seg1 = segments[i];
                        for (let j = 0; j < n; j++) {
                            if (i === j) continue;
                            const seg2 = segments[j];
                            if (zValues[i] >= zValues[j]) continue;
                            const avgLen = (seg1.length + seg2.length) / 2;
                            const shadow_cutoff = avgLen * 2.0;
                            const tint_cutoff = avgLen / 2.0;
                            const max_cutoff = shadow_cutoff + 10.0;
                            const dx = seg1.mid.x - seg2.mid.x; if (Math.abs(dx) > max_cutoff) continue;
                            const dy = seg1.mid.y - seg2.mid.y; if (Math.abs(dy) > max_cutoff) continue;
                            const dist2D = Math.sqrt(dx*dx + dy*dy); if (dist2D > max_cutoff) continue;
                            const dist3D = seg1.mid.distanceTo(seg2.mid);
                            if (dist3D < max_cutoff) { shadowSum += sigmoid(shadow_cutoff - dist3D); }
                            if (dist2D < tint_cutoff + 10.0) { maxTint = Math.max(maxTint, sigmoid(tint_cutoff - dist2D)); }
                        }
                        shadows[i] = Math.pow(this.shadowIntensity, shadowSum);
                        tints[i] = 1 - maxTint;
                    }
                    lighting.fill(1.0);  // Not used in quality mode
                }

                const order = Array.from({length: n}, (_, i) => i).sort((a, b) => zValues[a] - zValues[b]);
                
                const maxExtent = (trajectory && trajectory.maxExtent > 0) ? trajectory.maxExtent : 30.0;
                const dataRange = (maxExtent * 2) + this.lineWidth * 2;
                
                const canvasSize = Math.min(this.canvas.width, this.canvas.height);
                const scale = (canvasSize / dataRange) * this.zoom;
                const pyFigWidthPixels = 480.0;
                const pyPixelsPerData = pyFigWidthPixels / dataRange;
                const baseLineWidthPixels = (this.lineWidth * pyPixelsPerData) * this.zoom;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                for (const idx of order) {
                    const seg = segments[idx];
                    let {r, g, b} = colors[idx];
                    r /= 255; g /= 255; b /= 255;
                    
                    if (useFastLighting) {
                        // FAST MODE: Enhanced z-depth + directional lighting
                        // Brightened for better visibility
                        const depthFactor = 0.70 + 0.30 * zNorm[idx];  // 0.7 to 1.0
                        const lightFactor = 0.80 + 0.20 * lighting[idx];  // 0.8 to 1.0
                        const totalFactor = depthFactor * lightFactor;  // 0.56 to 1.0
                        r *= totalFactor; g *= totalFactor; b *= totalFactor;
                    } else {
                        // QUALITY MODE: Original shadow system
                        const tintFactor = (0.50 * zNorm[idx] + 0.50 * tints[idx]) / 3;
                        r = r + (1 - r) * tintFactor;
                        g = g + (1 - g) * tintFactor;
                        b = b + (1 - b) * tintFactor;
                        const shadowFactor = 0.20 + 0.25 * zNorm[idx] + 0.55 * shadows[idx];
                        r *= shadowFactor; g *= shadowFactor; b *= shadowFactor;
                    }
                    
                    const color = `rgb(${r*255|0},${g*255|0},${b*255|0})`;
                    const x1 = centerX + seg.start.x * scale; const y1 = centerY - seg.start.y * scale;
                    const x2 = centerX + seg.end.x * scale; const y2 = centerY - seg.end.y * scale;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.strokeStyle = color;
                    const type = this.atomTypes[seg.origIndex];
                    // Line width: RNA/DNA = 2x protein, Ligands = 0.5x protein
                    let widthMultiplier = 1.0;
                    if (type === 'L') {
                        widthMultiplier = 0.5;
                    } else if (type === 'D' || type === 'R') {
                        widthMultiplier = 2.0;
                    }
                    this.ctx.lineWidth = baseLineWidthPixels * widthMultiplier;
                    this.ctx.lineCap = 'round';
                    this.ctx.stroke();
                }
            }

            // --- REFACTORED: Main animation loop ---
            animate() {
                const now = performance.now();
                let needsRender = false;

                // 1. Handle inertia/spin
                if (!this.isDragging) { // REMOVED: isRecording check
                    if (Math.abs(this.spinVelocityX) > 0.0001) {
                        const rot = rotationMatrixY(this.spinVelocityX * 0.005);
                        this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix);
                        this.spinVelocityX *= 0.95; // Damping
                        needsRender = true;
                    } else {
                        this.spinVelocityX = 0;
                    }

                    if (Math.abs(this.spinVelocityY) > 0.0001) {
                        const rot = rotationMatrixX(this.spinVelocityY * 0.005);
                        this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix);
                        this.spinVelocityY *= 0.95; // Damping
                        needsRender = true;
                    } else {
                        this.spinVelocityY = 0;
                    }
                }

                // 2. Handle auto-rotate
                if (this.autoRotate && !this.isDragging && this.spinVelocityX === 0 && this.spinVelocityY === 0) { // REMOVED: isRecording check
                    const rot = rotationMatrixY(0.005); // Constant rotation speed
                    this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix);
                    needsRender = true;
                }

                // 3. Handle frame playback
                if (this.isPlaying) { // REMOVED: isRecording check
                    if (now - this.lastFrameAdvanceTime > this.animationSpeed) {
                        const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                        if (trajectory && trajectory.frames.length > 0) {
                            let nextFrame = this.currentFrame + 1;
                            if (nextFrame >= trajectory.frames.length) {
                                nextFrame = 0;
                            }
                            this.setFrame(nextFrame); // This calls render()
                            this.lastFrameAdvanceTime = now;
                            needsRender = false; // setFrame() already called render()
                        } else {
                            this.stopAnimation();
                        }
                    }
                }

                // 4. Final render if needed
                if (needsRender) {
                    this.render();
                }

                // 5. Loop
                requestAnimationFrame(() => this.animate());
            }
        }

        // ============================================================================
        // MAIN APP & COLAB COMMUNICATION
        // ============================================================================

        // 1. Get config from Python
        const config = window.viewerConfig || { size: [800, 600], color: "plddt" };

        // 2. Setup Canvas
        const canvas = document.getElementById('canvas');
        canvas.width = config.size[0];
        canvas.height = config.size[1];
        document.getElementById('mainContainer').style.width = `${config.size[0]}px`;

        // 3. Create renderer
        window.renderer = new Pseudo3DRenderer(canvas);
        window.renderer.colorMode = config.color;

        // 4. Setup general controls
        const colorSelect = document.getElementById('colorSelect');
        colorSelect.value = config.color;
        colorSelect.addEventListener('change', (e) => {
            window.renderer.colorMode = e.target.value;
            window.renderer.render();
        });
        const shadowCheckbox = document.getElementById('shadowCheckbox');
        window.renderer.shadowCheckbox = shadowCheckbox;  // Store reference
        shadowCheckbox.checked = window.renderer.shadowEnabled;
        shadowCheckbox.addEventListener('change', (e) => {
            window.renderer.shadowEnabled = e.target.checked;
            window.renderer.render();
        });

        // 5. Setup animation and trajectory controls
        const controlsContainer = document.getElementById('controlsContainer');
        const playButton = document.getElementById('playButton');
        // REMOVED: const saveVideoButton = document.getElementById('saveVideoButton');
        const frameSlider = document.getElementById('frameSlider');
        const frameCounter = document.getElementById('frameCounter');
        const trajectorySelect = document.getElementById('trajectorySelect');
        const speedSelect = document.getElementById('speedSelect');
        const rotationCheckbox = document.getElementById('rotationCheckbox');
        const lineWidthSlider = document.getElementById('lineWidthSlider');


        // Pass ALL controls to the renderer
        window.renderer.setUIControls(
            controlsContainer, playButton, 
            frameSlider, frameCounter, trajectorySelect, 
            speedSelect, rotationCheckbox, lineWidthSlider
        ); // MODIFIED: removed saveVideoButton

        // REFACTORED: All event listeners are now bound inside setUIControls
        // playButton.addEventListener('click', ...);
        // frameSlider.addEventListener('input', ...);
        // frameSlider.addEventListener('change', ...);


        // 6. Add function for Python to call (for new frames)
        window.handlePythonUpdate = (jsonData) => {
            try {
                const data = JSON.parse(jsonData);
                window.renderer.addFrame(data);
            } catch (e) {
                console.error("Failed to parse JSON from Python:", e);
            }
        };

        // 7. Add function for Python to start a new trajectory
        window.handlePythonNewTrajectory = (name) => {
            window.renderer.addTrajectory(name);
        };

        // 8. Load initial data
        try {
            if (window.proteinData && window.proteinData.coords && window.proteinData.coords.length > 0) {
                window.renderer.addFrame(window.proteinData);
            } else {
                const {coords, plddts, chains, atomTypes} = generateProteinCurve(100);
                const demoData = {
                    coords: coords.map(c => [c.x, c.y, c.z]),
                    plddts: plddts,
                    chains: chains,
                    atom_types: atomTypes
                };
                window.renderer.addFrame(demoData);
            }
        } catch (error) {
            console.error("Error loading initial data:", error);
            const {coords, plddts, chains, atomTypes} = generateProteinCurve(100);
            const demoData = { coords: coords.map(c => [c.x, c.v, c.z]), plddts: plddts, chains: chains, atom_types: atomTypes };
            window.renderer.addFrame(demoData);
        }

        // 9. Start the main animation loop
        window.renderer.animate();

    </script>
</body>
</html>