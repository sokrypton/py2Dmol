<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Protein Pseudo-3D Viewer</title>
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0;
            padding: 8px; /* Add some padding around the whole thing */
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #fff;
        }

        /* NEW: Main flex container */
        #mainContainer {
            display: flex;
            flex-direction: row;
            align-items: flex-start; /* Align tops */
            gap: 15px; /* Space between canvas column and controls column */
        }

        /* NEW: Left column for viewer and anim controls */
        #viewerColumn {
            display: flex;
            flex-direction: column;
            gap: 10px; /* Space between canvas and anim controls */
        }

        #canvasContainer {
            display: inline-block;
            /* MOVED: position: relative; */
            border: 1px solid #ddd;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }
        #canvas {
            background: #ffffff;
            cursor: grab;
            display: block;
        }
        #canvas:active {
            cursor: grabbing;
        }

/* MOVED: colorSelect and optionsContainer styles are now static */
        #colorSelect { /* REMOVED: shadowSelect styling */
            font-size: 12px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%; /* Make it fill its new container */
        }

        #optionsContainer {
            font-size: 12px;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px; /* Increased gap for clarity */
        }
        .toggle-item {
            display: flex;
            align-items: center;
            gap: 4px;
            /* MODIFIED: Add width for consistency */
            width: 100%;
        }
        .toggle-item label {
            cursor: pointer;
            white-space: nowrap;
            width: 50px; /* Give label a fixed width */
            flex-shrink: 0;
            font-size: 12px; /* Ensure label font size matches */
        }
        /* NEW: Style for the shadow/outline checkbox labels */
        .toggle-item label[for="shadowEnabledCheckbox"],
        .toggle-item label[for="outlineEnabledCheckbox"] {
            width: auto; /* Let it be auto-sized */
            margin-left: 5px; /* Add space next to the slider */
        }
        .toggle-item input[type="range"] {
            cursor: pointer;
            flex-grow: 1; /* Let slider fill the rest */
            width: auto; /* Let flexbox handle it */
            min-width: 0; /* Fix for flexbox overflow */
        }
        .toggle-item input[type="checkbox"] {
            cursor: pointer;
            margin: 0;
            flex-shrink: 0; /* Prevent checkbox from shrinking */
        }


        /* Animation Controls Container */
        #controlsContainer {
            display: flex;
            flex-wrap: nowrap;
            align-items: center;
            padding: 0 10px; /* Simplified padding */
            width: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 12px;
        }

        /* MOVED: trajectoryContainer is now in the right panel */
        #trajectoryContainer {
            font-size: 12px;
        }

        .controlButton {
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
            background: #f0f0f0;
            cursor: pointer;
            min-width: 60px;
            font-size: 12px;
            vertical-align: middle;
            margin-right: 5px;
            flex-shrink: 0;
        }
        .controlButton:disabled {
            cursor: not-allowed;
            background: #eee;
            color: #999;
        }
        #frameSlider {
            flex-grow: 1;
            width: auto;
            margin: 0 10px;
            vertical-align: middle;
        }
        #frameCounter {
            color: #333;
            vertical-align: middle;
            min-width: 80px;
            display: inline-block;
            flex-shrink: 0;
        }
        #speedSelect {
            font-size: 12px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            vertical-align: middle;
            margin-left: 10px;
            flex-shrink: 0;
        }

        #trajectorySelect {
            font-size: 12px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            vertical-align: middle;
            width: 100%; /* Make it fill */
        }
        #trajectorySelect:disabled {
             cursor: not-allowed;
            background: #eee;
        }

        /* NEW: Right panel for all other controls */
        #rightPanelContainer {
            display: flex;
            flex-direction: column;
            gap: 15px; /* Space between control groups */
            width: 160px; /* Give it a fixed width */
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            background: #fdfdfd;
            flex-shrink: 0; /* Don't let it shrink */
        }

/* NEW: Styling for groups in the right panel */
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .control-group > label {
            font-weight: 600;
            font-size: 12px;
            color: #333;
        }

    </style>
</head>
<body>
    <!-- Main container to hold viewer and controls -->
    <div id="mainContainer">

        <!-- NEW: Left Column -->
        <div id="viewerColumn">
            <!-- The canvas and dropdown are now siblings in the container -->
            <div id="canvasContainer">
                <canvas id="canvas"></canvas>
                <!-- MOVED optionsContainer and colorSelect to rightPanelContainer -->
            </div>

            <!-- Animation Controls -->
            <div id="controlsContainer">
                <button id="playButton" class="controlButton">Play</button>
                <input type="range" id="frameSlider" min="0" max="0" value="0">
                <span id="frameCounter">Frame: 0 / 0</span>
                <select id="speedSelect">
                    <option value="100">1x</option>
                    <option value="50">2x</option>
                    <option value="25">4x</option>
                </select>
            </div>
        </div>

        <!-- NEW: Right Column -->
        <div id="rightPanelContainer">

            <!-- MOVED: Color Select -->
            <div class="control-group">
                <label for="colorSelect">Color</label>
                <select id="colorSelect">
                    <option value="plddt">pLDDT</option>
                    <option value="rainbow">Rainbow</option>
                    <option value="chain">Chain</option>
                </select>
            </div>

            <!-- MOVED: Options Container -->
            <div id="optionsContainer" class="control-group">
                <!-- REMOVED shadowCheckbox -->
                <div class="toggle-item">
                    <input type="checkbox" id="rotationCheckbox">
                    <label for="rotationCheckbox">Rotate</label>
                </div>
                <div class="toggle-item">
                    <label for="lineWidthSlider">Width:</label>
                    <input type="range" id="lineWidthSlider" min="1" max="5" value="3" step="0.5">
                </div>
                <!-- MODIFIED: Shadow controls are now just a checkbox -->
                <div class="toggle-item">
                     <input type="checkbox" id="shadowEnabledCheckbox">
                     <label for="shadowEnabledCheckbox">Shadow</label>
                </div>
                <!-- NEW: Outline checkbox -->
                <div class="toggle-item">
                     <input type="checkbox" id="outlineEnabledCheckbox">
                     <label for="outlineEnabledCheckbox">Outline</label>
                </div>
            </div>

            <!-- MOVED: Trajectory Controls -->
            <div id="trajectoryContainer" class="control-group">
                <label for="trajectorySelect">Trajectory</label>
                <!-- MODIFIED: Removed the hardcoded 'default' option -->
                <select id="trajectorySelect">
                    <!-- Initially empty -->
                </select>
            </div>
        </div>
    </div>

    <!-- ... existing data injection point ... -->
    <!-- DATA_INJECTION_POINT -->

    <script>
        // ============================================================================
        // VECTOR MATH
        // ============================================================================
        class Vec3 {
            constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
            add(v) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }
            sub(v) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }
            mul(s) { return new Vec3(this.x * s, this.y * s, this.z * s); }
            dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z; }
            length() { return Math.sqrt(this.dot(this)); }
            distanceTo(v) { return this.sub(v).length(); }
            normalize() {
                const len = this.length();
                return len > 0 ? this.mul(1 / len) : new Vec3(0, 0, 1);
            }
        }
        function rotationMatrixX(angle) { const c = Math.cos(angle), s = Math.sin(angle); return [[1,0,0], [0,c,-s], [0,s,c]]; }
        function rotationMatrixY(angle) { const c = Math.cos(angle), s = Math.sin(angle); return [[c,0,s], [0,1,0], [-s,0,c]]; }
        function multiplyMatrices(a, b) { const r = [[0,0,0],[0,0,0],[0,0,0]]; for (let i = 0; i < 3; i++) for (let j = 0; j < 3; j++) for (let k = 0; k < 3; k++) r[i][j] += a[i][k] * b[k][j]; return r; }
        function applyMatrix(m, v) { return new Vec3(m[0][0]*v.x + m[0][1]*v.y + m[0][2]*v.z, m[1][0]*v.x + m[1][1]*v.y + m[1][2]*v.z, m[2][0]*v.x + m[2][1]*v.y + m[2][2]*v.z); }
        function sigmoid(x) {
            return 1 / (1 + Math.exp(-x));
        }
        function sigmoid(x) {
            return 0.5 + x / (2 * (1 + Math.abs(x)));
        }
        // ============================================================================
        // COLOR UTILITIES
        // ============================================================================
        const pymolColors = ["#33ff33","#00ffff","#ff33cc","#ffff00","#ff9999","#e5e5e5","#7f7fff","#ff7f00","#7fff7f","#199999","#ff007f","#ffdd5e","#8c3f99","#b2b2b2","#007fff","#c4b200","#8cb266","#00bfbf","#b27f7f","#fcd1a5","#ff7f7f","#ffbfdd","#7fffff","#ffff7f","#00ff7f","#337fcc","#d8337f","#bfff3f","#ff7fff","#d8d8ff","#3fffbf","#b78c4c","#339933","#66b2b2","#ba8c84","#84bf00","#b24c66","#7f7f7f","#3f3fa5","#a5512b"];
        function hexToRgb(hex) { if (!hex || typeof hex !== 'string') { return {r: 128, g: 128, b: 128}; } const r = parseInt(hex.slice(1,3), 16); const g = parseInt(hex.slice(3,5), 16); const b = parseInt(hex.slice(5,7), 16); return {r, g, b}; }
        function hsvToRgb(h, s, v) { const c = v * s; const x = c * (1 - Math.abs((h / 60) % 2 - 1)); const m = v - c; let r, g, b; if (h < 60) { r = c; g = x; b = 0; } else if (h < 120) { r = x; g = c; b = 0; } else if (h < 180) { r = 0; g = c; b = x; } else if (h < 240) { r = 0; g = x; b = c; } else if (h < 300) { r = x; g = 0; b = c; } else { r = c; g = 0; b = x; } return { r: Math.round((r + m) * 255), g: Math.round((g + m) * 255), b: Math.round((b + m) * 255) }; }
        function getRainbowColor(value, min, max) { if (max - min < 1e-6) return hsvToRgb(0, 1.0, 1.0); let normalized = (value - min) / (max - min); normalized = Math.max(0, Math.min(1, normalized)); const hue = 240 * normalized; return hsvToRgb(hue, 1.0, 1.0); }
        function getPlddtColor(plddt) { return getRainbowColor(plddt, 50, 90); }
        function getChainColor(chainIndex) { if (chainIndex < 0) chainIndex = 0; return hexToRgb(pymolColors[chainIndex % pymolColors.length]); }

        // ============================================================================
        // PSEUDO-3D RENDERER
        // ============================================================================
        class Pseudo3DRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');

                // Get config from Python
                const config = window.viewerConfig || {
                    size: [800, 600],
                    color: "plddt",
                    default_shadow: true,
                    default_outline: true,
                    default_width: 3.0,
                    default_rotate: false
                };

                // Current render state
                this.coords = [];
                this.plddts = [];
                this.chains = [];
                this.atomTypes = [];

                // Viewer state
                this.colorMode = config.color; // Set initial color from config
                this.rotationMatrix = [[1,0,0],[0,1,0],[0,0,1]];
                this.zoom = 1.0;
                this.lineWidth = (typeof config.default_width === 'number') ? config.default_width : 3.0; // NEW
                this.shadowIntensity = 0.95;

                // Set defaults from config, with fallback
                this.shadowEnabled = (typeof config.default_shadow === 'boolean') ? config.default_shadow : true;
                this.outlineEnabled = (typeof config.default_outline === 'boolean') ? config.default_outline : true;

                // Performance
                this.chainRainbowScales = {};

                // --- REFACTORED: Animation & State ---
                this.trajectoriesData = {}; // { "default": { maxExtent: 0, frames: [], globalCenterSum: new Vec3(0,0,0), totalAtoms: 0 } };
                this.currentTrajectoryName = null; // "default";
                this.currentFrame = -1;

                // Playback
                this.isPlaying = false;
                this.animationSpeed = 100; // ms per frame
                this.lastFrameAdvanceTime = 0;

                // Interaction
                this.isDragging = false;
                this.autoRotate = (typeof config.default_rotate === 'boolean') ? config.default_rotate : false; // NEW

                // Inertia
                this.spinVelocityX = 0;
                this.spinVelocityY = 0;
                this.lastDragTime = 0;
                this.lastDragX = 0;
                this.lastDragY = 0;

                // Track slider interaction
                this.isSliderDragging = false;

                // UI elements
                this.playButton = null;
                this.frameSlider = null;
                this.frameCounter = null;
                this.trajectorySelect = null;
                this.controlsContainer = null;
                this.speedSelect = null;
                this.rotationCheckbox = null;
                this.lineWidthSlider = null;
                this.shadowEnabledCheckbox = null;
                this.outlineEnabledCheckbox = null; // NEW

                this.setupInteraction();
            }

            setupInteraction() {
                // --- REFACTORED: Added inertia logic ---
                this.canvas.addEventListener('mousedown', (e) => {
                    // Only start dragging if we clicked directly on the canvas
                    if (e.target !== this.canvas) return;

                    this.isDragging = true;
                    this.spinVelocityX = 0;
                    this.spinVelocityY = 0;
                    this.lastDragX = e.clientX;
                    this.lastDragY = e.clientY;
                    this.lastDragTime = performance.now();
                    if (this.autoRotate) {
                        this.autoRotate = false;
                        if (this.rotationCheckbox) this.rotationCheckbox.checked = false;
                    }
                }); // <-- FIX: Closed the mousedown listener here

                window.addEventListener('mousemove', (e) => {
                    if (!this.isDragging) return;

                    // SLIDER FIX: Clear isDragging and stop if over a control element
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON') {
                        this.isDragging = false;
                        return;
                    }

                    const now = performance.now();
                    const timeDelta = now - this.lastDragTime;

                    const dx = e.clientX - this.lastDragX;
                    const dy = e.clientY - this.lastDragY;

                    if (dy !== 0) { const rot = rotationMatrixX(dy * 0.01); this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix); }
                    if (dx !== 0) { const rot = rotationMatrixY(dx * 0.01); this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix); }

                    // Store velocity for inertia
                    if (timeDelta > 0) {
                        // Weighted average to smooth out jerky movements
                        const smoothing = 0.5;
                        this.spinVelocityX = (this.spinVelocityX * (1-smoothing)) + ((dx / timeDelta * 20) * smoothing);
                        this.spinVelocityY = (this.spinVelocityY * (1-smoothing)) + ((dy / timeDelta * 20) * smoothing);
                    }

                    this.lastDragX = e.clientX;
                    this.lastDragY = e.clientY;
                    this.lastDragTime = now;

                    // MODIFIED: Reverted to full render on drag
                    this.render();
                });

                window.addEventListener('mouseup', () => {
                    // MODIFIED: Removed extra render call
                    this.isDragging = false;
                    const now = performance.now();
                    const timeDelta = now - this.lastDragTime;

                    if (timeDelta > 100) { // If drag was too slow, or just a click
                        this.spinVelocityX = 0;
                        this.spinVelocityY = 0;
                    }
                    // Else, the velocity from the last mousemove is used by the animate loop
                });

                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.zoom *= (1 - e.deltaY * 0.001);
                    this.zoom = Math.max(0.1, Math.min(5, this.zoom));
                    this.render();
                }, { passive: false });
            }

            // Set UI controls from main script
            // MODIFIED: Added outlineEnabledCheckbox
            setUIControls(controlsContainer, playButton, frameSlider, frameCounter, trajectorySelect, speedSelect, rotationCheckbox, lineWidthSlider, shadowEnabledCheckbox, outlineEnabledCheckbox) {
                this.controlsContainer = controlsContainer;
                this.playButton = playButton;
                this.frameSlider = frameSlider;
                this.frameCounter = frameCounter;
                this.trajectorySelect = trajectorySelect;
                this.speedSelect = speedSelect;
                this.rotationCheckbox = rotationCheckbox;
                this.lineWidthSlider = lineWidthSlider;
                this.shadowEnabledCheckbox = shadowEnabledCheckbox;
                this.outlineEnabledCheckbox = outlineEnabledCheckbox; // NEW

                this.lineWidth = parseFloat(this.lineWidthSlider.value); // Read default from slider
                this.autoRotate = this.rotationCheckbox.checked; // Read default from checkbox

                // --- BIND ALL EVENT LISTENERS HERE ---
                this.playButton.addEventListener('click', () => {
                    this.togglePlay();
                });

                this.trajectorySelect.addEventListener('change', () => {
                    this.stopAnimation();
                    this.currentTrajectoryName = this.trajectorySelect.value;
                    this.setFrame(0);
                });

                this.speedSelect.addEventListener('change', (e) => {
                    this.animationSpeed = parseInt(e.target.value);
                });

                this.rotationCheckbox.addEventListener('change', (e) => {
                    this.autoRotate = e.target.checked;
                    // Stop inertia if user clicks auto-rotate
                    this.spinVelocityX = 0;
                    this.spinVelocityY = 0;
                });

                this.lineWidthSlider.addEventListener('input', (e) => {
                    this.lineWidth = parseFloat(e.target.value);
                    if (!this.isPlaying) {
                        this.render();
                    }
                });

                // NEW: Add listener for shadowEnabledCheckbox
                if (this.shadowEnabledCheckbox) {
                    this.shadowEnabledCheckbox.addEventListener('change', (e) => {
                        this.shadowEnabled = e.target.checked;
                        this.render();
                    });
                }

                // NEW: Add listener for outlineEnabledCheckbox
                if (this.outlineEnabledCheckbox) {
                    this.outlineEnabledCheckbox.addEventListener('change', (e) => {
                        this.outlineEnabled = e.target.checked;
                        this.render();
                    });
                }

                // --- SLIDER FIX: Prevent canvas drag from interfering with slider ---
                const handleSliderChange = (e) => {
                    this.stopAnimation();
                    this.setFrame(parseInt(e.target.value));
                };

                // Track when user is interacting with slider
                this.frameSlider.addEventListener('mousedown', (e) => {
                    this.isDragging = false;
                    this.isSliderDragging = true;
                    e.stopPropagation();
                });

                this.frameSlider.addEventListener('mouseup', (e) => {
                    this.isSliderDragging = false;
                });

                // Also clear on window mouseup in case user releases outside slider
                window.addEventListener('mouseup', () => {
                    this.isSliderDragging = false;
                });

                this.frameSlider.addEventListener('input', handleSliderChange);
                this.frameSlider.addEventListener('change', handleSliderChange);

                // Also prevent canvas drag when interacting with other controls
                // MODIFIED: Updated controls list
                const allControls = [this.playButton, this.trajectorySelect, this.speedSelect,
                                     this.rotationCheckbox, this.lineWidthSlider,
                                     this.shadowEnabledCheckbox, this.outlineEnabledCheckbox]; // NEW
                allControls.forEach(control => {
                    if (control) {
                        control.addEventListener('mousedown', (e) => {
                            this.isDragging = false;
                            e.stopPropagation();
                        });
                    }
                });
            }

            // Add a new trajectory
            addTrajectory(name) {
                this.stopAnimation();
                this.trajectoriesData[name] = { maxExtent: 0, frames: [], globalCenterSum: new Vec3(0,0,0), totalAtoms: 0 };
                this.currentTrajectoryName = name;
                this.currentFrame = -1;

                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                this.trajectorySelect.appendChild(option);
                this.trajectorySelect.value = name;

                // --- MODIFICATION: Call setFrame(-1) to clear canvas ---
                // this.updateUIControls(); // OLD
                this.setFrame(-1); // NEW: This clears canvas and updates UI
                // --- END MODIFICATION ---
            }

            // Add a frame (data is raw parsed JSON)
            // --- MODIFICATION: Added trajectoryName parameter ---
            addFrame(data, trajectoryName) {

                // --- MODIFICATION: Use explicit trajectoryName from Python ---
                let targetTrajectoryName = trajectoryName;
                if (!targetTrajectoryName) {
                    // Fallback just in case, though Python should always send it.
                    console.warn("addFrame called without trajectoryName, using current view.");
                    targetTrajectoryName = this.currentTrajectoryName;
                }

                if (!targetTrajectoryName) {
                    // This can happen if addFrame is called before new_traj
                    // The python logic should prevent this, but as a robust fallback:
                    console.warn("addFrame: No trajectory active. Creating '0'.");
                    this.addTrajectory("0");
                    targetTrajectoryName = "0";
                }

                if (!this.trajectoriesData[targetTrajectoryName]) {
                     console.error(`addFrame: Trajectory '${targetTrajectoryName}' does not exist.`);
                     // This could happen if messages arrive out of order.
                     // Let's create it to be safe.
                     console.warn(`addFrame: Trajectory '${targetTrajectoryName}' not found. Creating it.`);
                     this.addTrajectory(targetTrajectoryName);
                     // Note: addTrajectory sets view to this new trajectory.
                }
                // --- END MODIFICATION ---

                const trajectory = this.trajectoriesData[targetTrajectoryName];
                trajectory.frames.push(data);

                // --- NEW: Set view to this trajectory ---
                if (this.currentTrajectoryName !== targetTrajectoryName) {
                    this.stopAnimation(); // Stop if playing on another traj
                    this.currentTrajectoryName = targetTrajectoryName;
                    this.trajectorySelect.value = targetTrajectoryName;
                }
                // --- END NEW ---

                // --- Update global center sum and count ---
                let frameSum = new Vec3(0,0,0);
                let frameAtoms = 0;
                if (data && data.coords) {
                    frameAtoms = data.coords.length;
                    for (const c of data.coords) {
                        frameSum = frameSum.add(new Vec3(c[0], c[1], c[2]));
                    }
                    trajectory.globalCenterSum = trajectory.globalCenterSum.add(frameSum);
                    trajectory.totalAtoms += frameAtoms;
                }

                const globalCenter = (trajectory.totalAtoms > 0) ? trajectory.globalCenterSum.mul(1 / trajectory.totalAtoms) : new Vec3(0,0,0);

                // --- Recalculate maxExtent for *all* frames using the *new* global center ---
                let maxDistSq = 0;
                for (const frame of trajectory.frames) {
                    if (frame && frame.coords) {
                        for (const c of frame.coords) {
                            const coordVec = new Vec3(c[0], c[1], c[2]);
                            const centeredCoord = coordVec.sub(globalCenter);
                            const distSq = centeredCoord.dot(centeredCoord);
                            if (distSq > maxDistSq) maxDistSq = distSq;
                        }
                    }
                }
                trajectory.maxExtent = Math.sqrt(maxDistSq);

                if (!this.isPlaying) {
                    this.setFrame(trajectory.frames.length - 1);
                }
                this.updateUIControls();
            }

            // Set the current frame and render it
            setFrame(frameIndex) {
                frameIndex = parseInt(frameIndex);
                // MODIFIED: Handle null trajectory name
                if (!this.currentTrajectoryName) {
                    this.currentFrame = -1;
                    this.coords = []; // Clear coords
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.updateUIControls();
                    this.setUIEnabled(false); // Disable controls if no trajectory
                    return;
                }

                const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                if (!trajectory || frameIndex < 0 || frameIndex >= trajectory.frames.length) {
                    this.currentFrame = -1;
                    this.coords = []; // Clear coords
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    this.updateUIControls();
                    this.setUIEnabled(true); // Enable, even if frame is invalid (so user can change traj)
                    return;
                }

                this.currentFrame = frameIndex;
                const data = trajectory.frames[frameIndex];
                this._loadDataIntoRenderer(data); // This calls render()
                this.updateUIControls(); // Update slider value
                this.setUIEnabled(true); // Make sure controls are enabled
            }

            // Update UI element states (e.g., disabled)
            setUIEnabled(enabled) {
                 this.playButton.disabled = !enabled;
                 this.frameSlider.disabled = !enabled;
                 this.trajectorySelect.disabled = !enabled;
                 this.speedSelect.disabled = !enabled;
                 this.rotationCheckbox.disabled = !enabled;
                 this.lineWidthSlider.disabled = !enabled;
                 if (this.shadowEnabledCheckbox) this.shadowEnabledCheckbox.disabled = !enabled;
                 if (this.outlineEnabledCheckbox) this.outlineEnabledCheckbox.disabled = !enabled; // NEW
                 this.canvas.style.cursor = enabled ? 'grab' : 'wait';
            }

            // Update the text/slider values
            updateUIControls() {
                if (!this.playButton) return;

                // MODIFIED: Handle null trajectory
                const trajectory = this.currentTrajectoryName ? this.trajectoriesData[this.currentTrajectoryName] : null;
                const total = trajectory ? trajectory.frames.length : 0;
                const current = Math.max(0, this.currentFrame) + 1;

                if (total <= 1) {
                    this.controlsContainer.style.display = 'none';
                } else {
                    this.controlsContainer.style.display = 'flex';
                }

                this.frameSlider.max = Math.max(0, total - 1);

                // CRITICAL FIX: Don't update slider value while user is dragging it!
                if (!this.isSliderDragging) {
                    this.frameSlider.value = this.currentFrame;
                }

                this.frameCounter.textContent = `Frame: ${total > 0 ? current : 0} / ${total}`;
                this.playButton.textContent = this.isPlaying ? 'Pause' : 'Play';
            }

            // Toggle play/pause
            togglePlay() {
                if (this.isPlaying) {
                    this.stopAnimation();
                } else {
                    this.startAnimation();
                }
            }

            // --- REFACTORED: Start playback ---
            startAnimation() {
                // MODIFIED: Check for null
                if (!this.currentTrajectoryName) return;
                const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                if (!trajectory || trajectory.frames.length < 2) return;

                this.isPlaying = true;
                this.lastFrameAdvanceTime = performance.now(); // Set start time
                this.updateUIControls();
            }

            // --- REFACTORED: Stop playback ---
            stopAnimation() {
                this.isPlaying = false;
                this.updateUIControls();
            }

            // NEW: Clear all trajectories
            clearAllTrajectories() {
                this.stopAnimation();

                // Reset data
                // MODIFIED: Just clear, don't recreate 'default'
                this.trajectoriesData = {};
                this.currentTrajectoryName = null;

                // Reset trajectory dropdown
                if (this.trajectorySelect) {
                    this.trajectorySelect.innerHTML = ''; // Clear all options
                }

                // Set to empty frame, which clears canvas and updates UI
                this.setFrame(-1);
            }

            // Load data into renderer
            _loadDataIntoRenderer(data) {
                try {
                    if (data && data.coords && data.coords.length > 0) {
                        const coords = data.coords.map(c => new Vec3(c[0], c[1], c[2]));
                        const plddts = data.plddts || [];
                        const chains = data.chains || [];
                        const atomTypes = data.atom_types || [];
                        this.setCoords(coords, plddts, chains, atomTypes);
                    }
                } catch (e) {
                    console.error("Failed to load data into renderer:", e);
                }
                // BUG FIX: Call render AFTER setting coords, not inside _loadData...
                // this.render(); // OLD
            }

            // Set current coordinates
            setCoords(coords, plddts = [], chains = [], atomTypes = []) {
                this.coords = coords;
                this.plddts = plddts;
                this.chains = chains;
                this.atomTypes = atomTypes;

                if (this.plddts.length !== this.coords.length) { this.plddts = Array(this.coords.length).fill(50.0); }
                if (this.chains.length !== this.coords.length) { this.chains = Array(this.coords.length).fill('A'); }
                if (this.atomTypes.length !== this.coords.length) { this.atomTypes = Array(this.coords.length).fill('P'); }

                // MODIFIED: Removed auto-setting of shadowApproxSlider
                const n = this.coords.length;

                this.chainRainbowScales = {};
                for (let i = 0; i < this.atomTypes.length; i++) {
                    const type = this.atomTypes[i];
                    // Include protein (P), DNA (D), and RNA (R) in rainbow coloring
                    if (type === 'P' || type === 'D' || type === 'R') {
                        const chainId = this.chains[i] || 'A';
                        if (!this.chainRainbowScales[chainId]) {
                            this.chainRainbowScales[chainId] = { min: Infinity, max: -Infinity };
                        }
                        const colorIndex = this.coords.length - 1 - i;
                        const scale = this.chainRainbowScales[chainId];
                        scale.min = Math.min(scale.min, colorIndex);
                        scale.max = Math.max(scale.max, colorIndex);
                    }
                }

                // BUG FIX: Trigger a render AFTER setting coords and potentially deciding on shadow mode
                this.render();
            }

            // --- RENDER (Core drawing logic) ---
            // MODIFIED: Removed forceShadowMode parameter
            render() {
                const startTime = performance.now();
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                // MODIFIED: Check for null trajectory
                if (this.coords.length === 0 || !this.currentTrajectoryName) return;

                const trajectory = this.trajectoriesData[this.currentTrajectoryName];

                // MODIFIED: Check if trajectory data actually exists
                if (!trajectory) {
                    console.warn("Render called but trajectory data is missing.");
                    return;
                }

                const globalCenter = (trajectory && trajectory.totalAtoms > 0) ? trajectory.globalCenterSum.mul(1 / trajectory.totalAtoms) : new Vec3(0,0,0);

                const rotated = this.coords.map(v => applyMatrix(this.rotationMatrix, v.sub(globalCenter)));
                const segments = [];
                const proteinChainbreak = 5.0;
                const nucleicChainbreak = 7.5; // DNA/RNA C4'-C4' distance
                const ligandBondCutoff = 2.0;
                let firstPolymerIndex = -1;
                let lastPolymerIndex = -1;
                const ligandIndices = [];

                // Helper function to check if atom is polymer (protein or nucleic)
                const isPolymer = (type) => (type === 'P' || type === 'D' || type === 'R');
                const getChainbreakDist = (type1, type2) => {
                    if ((type1 === 'D' || type1 === 'R') && (type2 === 'D' || type2 === 'R')) {
                        return nucleicChainbreak;
                    }
                    return proteinChainbreak;
                };

                for (let i = 0; i < rotated.length; i++) {
                    const type = this.atomTypes[i];

                    if (type === 'L') {
                        ligandIndices.push(i);
                        continue;
                    }

                    if (isPolymer(type)) {
                        if (firstPolymerIndex === -1) { firstPolymerIndex = i; }
                        lastPolymerIndex = i;

                        if (i < rotated.length - 1) {
                            const type1 = this.atomTypes[i];
                            const type2 = this.atomTypes[i+1];

                            // Check if both are polymer atoms of compatible types
                            if (isPolymer(type1) && isPolymer(type2)) {
                                // Can connect: P-P, D-D, R-R (but not P-D, P-R, D-R)
                                const samePolymerType = (type1 === type2) ||
                                    ((type1 === 'D' || type1 === 'R') && (type2 === 'D' || type2 === 'R'));

                                if (samePolymerType && this.chains[i] === this.chains[i+1]) {
                                    const start = rotated[i];
                                    const end = rotated[i+1];
                                    const dist = start.distanceTo(end);
                                    const chainbreakDist = getChainbreakDist(type1, type2);

                                    if (dist < chainbreakDist) {
                                        segments.push({
                                            start,
                                            end,
                                            mid: start.add(end).mul(0.5),
                                            length: dist,
                                            colorIndex: rotated.length - 1 - i,
                                            origIndex: i,
                                            chainId: this.chains[i] || 'A'
                                        });
                                    }
                                }
                            }
                        }
                    }
                }

                // Close loop for polymer if first and last are same chain and close enough
                if (firstPolymerIndex !== -1 && lastPolymerIndex !== -1 && firstPolymerIndex !== lastPolymerIndex) {
                    const firstChainId = this.chains[firstPolymerIndex] || 'A';
                    const lastChainId = this.chains[lastPolymerIndex] || 'A';
                    const type1 = this.atomTypes[firstPolymerIndex];
                    const type2 = this.atomTypes[lastPolymerIndex];

                    if (firstChainId === lastChainId && isPolymer(type1) && isPolymer(type2)) {
                        const samePolymerType = (type1 === type2) ||
                            ((type1 === 'D' || type1 === 'R') && (type2 === 'D' || type2 === 'R'));

                        if (samePolymerType) {
                            const start = rotated[firstPolymerIndex];
                            const end = rotated[lastPolymerIndex];
                            const dist = start.distanceTo(end);
                            const chainbreakDist = getChainbreakDist(type1, type2);

                            if (dist < chainbreakDist) {
                                segments.push({
                                    start,
                                    end,
                                    mid: start.add(end).mul(0.5),
                                    length: dist,
                                    colorIndex: this.chainRainbowScales[firstChainId]?.min || 0,
                                    origIndex: firstPolymerIndex,
                                    chainId: firstChainId
                                });
                            }
                        }
                    }
                }

                for (let i = 0; i < ligandIndices.length; i++) {
                    for (let j = i + 1; j < ligandIndices.length; j++) {
                        const idx1 = ligandIndices[i];
                        const idx2 = ligandIndices[j];
                        const start = rotated[idx1];
                        const end = rotated[idx2];
                        const dist = start.distanceTo(end);
                        if (dist < ligandBondCutoff) {
                             segments.push({ start, end, mid: start.add(end).mul(0.5), length: dist, colorIndex: 0, origIndex: idx1, chainId: this.chains[idx1] || 'A' });
                        }
                    }
                }

                if (segments.length === 0) return;
                const n = segments.length; // Get segment count early

                // PERFORMANCE: Pre-compute unique chains once for chain coloring mode
                const uniqueChains = (this.colorMode === 'chain' && this.chains.length > 0)
                    ? [...new Set(this.chains)]
                    : [];

                const grey = {r: 128, g: 128, b: 128};
                const colors = segments.map(seg => {
                    const i = seg.origIndex;
                    const type = this.atomTypes[i];
                    if (type === 'L') {
                        if (this.colorMode === 'plddt') {
                            const plddt1 = (this.plddts[i] !== null && this.plddts[i] !== undefined) ? this.plddts[i] : 50;
                            return getPlddtColor(plddt1);
                        }
                        return grey;
                    }
                    if (this.colorMode === 'plddt') {
                        const plddt1 = (this.plddts[i] !== null && this.plddts[i] !== undefined) ? this.plddts[i] : 50;
                        const plddt2_idx = (seg.origIndex + 1 < this.coords.length) ? seg.origIndex + 1 : seg.origIndex;
                        const plddt2 = (this.plddts[plddt2_idx] !== null && this.plddts[plddt2_idx] !== undefined) ? this.plddts[plddt2_idx] : 50;
                        return getPlddtColor((plddt1 + plddt2) / 2);
                    }
                    else if (this.colorMode === 'chain') {
                        if (uniqueChains.length === 0) return getChainColor(0);
                        const chainId = this.chains[i] || 'A';
                        const chainIndex = uniqueChains.indexOf(chainId);
                        return getChainColor(chainIndex >= 0 ? chainIndex : 0);
                    }
                    else {
                        const scale = this.chainRainbowScales[seg.chainId];
                        if (scale) { return getRainbowColor(seg.colorIndex, scale.min, scale.max); }
                        else { return grey; }
                    }
                });

                const zValues = segments.map(s => (s.start.z + s.end.z) / 2);
                const zMin = Math.min(...zValues);
                const zMax = Math.max(...zValues);
                const zNorm = zValues.map(z => zMax - zMin > 1e-6 ? (z - zMin) / (zMax - zMin) : 0);

                // MODIFIED: Simplified renderShadows check
                const renderShadows = this.shadowEnabled;

                // BUG FIX: Moved maxExtent declaration here, BEFORE shadow logic
                const maxExtent = (trajectory && trajectory.maxExtent > 0) ? trajectory.maxExtent : 30.0;

                const shadows = new Float32Array(n);
                const tints = new Float32Array(n);

                // --- OPTIMIZED: Implement Hybrid Shadow Logic ---
                if (renderShadows) {
                    // Note: shadows and tints arrays already declared above (lines 942-943)

                    if (n <= 1000) {
                        // --- O(N^2) Path (Optimized for small N) ---

                        // Precompute all segment data to avoid repeated property lookups
                        const segData = new Array(n);
                        for (let i = 0; i < n; i++) {
                            const seg = segments[i];
                            const mid = seg.mid;
                            segData[i] = {
                                x: mid.x,
                                y: mid.y,
                                z: mid.z,
                                len: seg.length,
                                zVal: zValues[i]
                            };
                        }

                        for (let i = 0; i < n; i++) {
                            let shadowSum = 0;
                            let maxTint = 0;
                            const s1 = segData[i];
                            const s1_x = s1.x;
                            const s1_y = s1.y;
                            const s1_z = s1.z;
                            const s1_len = s1.len;
                            const s1_zVal = s1.zVal;

                            for (let j = 0; j < n; j++) {
                                if (i === j) continue;

                                const s2 = segData[j];

                                // Early z-value check
                                if (s1_zVal >= s2.zVal) continue;

                                // Precompute cutoffs (avoid repeated calculations)
                                const avgLen = (s1_len + s2.len) * 0.5; // Multiply by 0.5 instead of divide by 2
                                const shadow_cutoff = avgLen * 2.0;
                                const tint_cutoff = avgLen * 0.5;
                                const max_cutoff = shadow_cutoff + 10.0;

                                // Early rejection with absolute value checks
                                const dx = s1_x - s2.x;
                                const dy = s1_y - s2.y;

                                if (Math.abs(dx) > max_cutoff || Math.abs(dy) > max_cutoff) continue;

                                // Compute 2D distance squared (delay sqrt as long as possible)
                                const dist2D_sq = dx * dx + dy * dy;
                                const max_cutoff_sq = max_cutoff * max_cutoff;

                                if (dist2D_sq > max_cutoff_sq) continue;

                                // Shadow calculation
                                const dz = s1_z - s2.z;
                                const dist3D_sq = dist2D_sq + dz * dz;

                                if (dist3D_sq < max_cutoff_sq) {
                                    const dist3D = Math.sqrt(dist3D_sq);
                                    shadowSum += sigmoid(shadow_cutoff - dist3D);
                                }

                                // Tint calculation - work with squared distances
                                const tint_max_cutoff = tint_cutoff + 10.0;
                                const tint_max_cutoff_sq = tint_max_cutoff * tint_max_cutoff;

                                if (dist2D_sq < tint_max_cutoff_sq) {
                                    // Only compute sqrt when necessary
                                    const dist2D = Math.sqrt(dist2D_sq);
                                    maxTint = Math.max(maxTint, sigmoid(tint_cutoff - dist2D));
                                }
                            }

                            shadows[i] = Math.pow(this.shadowIntensity, shadowSum);
                            tints[i] = 1 - maxTint;
                        }

                    } else {
                        // --- Spatial Grid Path (Optimized for large N) ---

                        let GRID_DIM = Math.ceil(Math.sqrt(n / 10)); // Aim for ~10 items/cell
                        GRID_DIM = Math.max(10, Math.min(100, GRID_DIM)); // Cap 10x10 to 100x100

                        const gridSize = GRID_DIM * GRID_DIM;
                        const grid = Array.from({ length: gridSize }, () => []);

                        const gridMin = -maxExtent - 1.0;
                        const gridRange = (maxExtent + 1.0) * 2;
                        const gridCellSize = gridRange / GRID_DIM;

                        // Precompute all segment data
                        const segData = new Array(n);
                        for (let i = 0; i < n; i++) {
                            const seg = segments[i];
                            const mid = seg.mid;
                            segData[i] = {
                                x: mid.x,
                                y: mid.y,
                                z: mid.z,
                                len: seg.length,
                                zVal: zValues[i],
                                gx: -1,
                                gy: -1
                            };
                        }

                        // Build spatial grid
                        if (gridCellSize > 1e-6) {
                            const invCellSize = 1.0 / gridCellSize; // Multiply instead of divide

                            for (let i = 0; i < n; i++) {
                                const s = segData[i];
                                const gx = Math.floor((s.x - gridMin) * invCellSize);
                                const gy = Math.floor((s.y - gridMin) * invCellSize);

                                if (gx >= 0 && gx < GRID_DIM && gy >= 0 && gy < GRID_DIM) {
                                    s.gx = gx;
                                    s.gy = gy;
                                    const gridIndex = gx + gy * GRID_DIM;
                                    grid[gridIndex].push(i);
                                }
                            }
                        }

                        // Process each segment
                        for (let i = 0; i < n; i++) {
                            let shadowSum = 0;
                            let maxTint = 0;
                            const s1 = segData[i];
                            const s1_x = s1.x;
                            const s1_y = s1.y;
                            const s1_z = s1.z;
                            const s1_len = s1.len;
                            const s1_zVal = s1.zVal;
                            const gx1 = s1.gx;
                            const gy1 = s1.gy;

                            if (gx1 < 0 || gy1 < 0) continue;

                            // Check 3x3 neighborhood around the segment
                            for (let dy = -1; dy <= 1; dy++) {
                                const gy2 = gy1 + dy;
                                if (gy2 < 0 || gy2 >= GRID_DIM) continue;

                                const rowOffset = gy2 * GRID_DIM;

                                for (let dx = -1; dx <= 1; dx++) {
                                    const gx2 = gx1 + dx;
                                    if (gx2 < 0 || gx2 >= GRID_DIM) continue;

                                    const gridIndex = gx2 + rowOffset;
                                    const cell = grid[gridIndex];
                                    const cellLen = cell.length;

                                    for (let k = 0; k < cellLen; k++) {
                                        const j = cell[k];
                                        if (i === j) continue;

                                        const s2 = segData[j];

                                        // Early z-value check
                                        if (s1_zVal >= s2.zVal) continue;

                                        // Precompute cutoffs
                                        const avgLen = (s1_len + s2.len) * 0.5;
                                        const shadow_cutoff = avgLen * 2.0;
                                        const tint_cutoff = avgLen * 0.5;
                                        const max_cutoff = shadow_cutoff + 10.0;

                                        // Early rejection with absolute value checks
                                        const dx_dist = s1_x - s2.x;
                                        const dy_dist = s1_y - s2.y;

                                        if (Math.abs(dx_dist) > max_cutoff || Math.abs(dy_dist) > max_cutoff) continue;

                                        // Compute 2D distance squared
                                        const dist2D_sq = dx_dist * dx_dist + dy_dist * dy_dist;
                                        const max_cutoff_sq = max_cutoff * max_cutoff;

                                        if (dist2D_sq > max_cutoff_sq) continue;

                                        // Shadow calculation
                                        const dz = s1_z - s2.z;
                                        const dist3D_sq = dist2D_sq + dz * dz;

                                        if (dist3D_sq < max_cutoff_sq) {
                                            const dist3D = Math.sqrt(dist3D_sq);
                                            shadowSum += sigmoid(shadow_cutoff - dist3D);
                                        }

                                        // Tint calculation
                                        const tint_max_cutoff = tint_cutoff + 10.0;
                                        const tint_max_cutoff_sq = tint_max_cutoff * tint_max_cutoff;

                                        if (dist2D_sq < tint_max_cutoff_sq) {
                                            const dist2D = Math.sqrt(dist2D_sq);
                                            maxTint = Math.max(maxTint, sigmoid(tint_cutoff - dist2D));
                                        }
                                    }
                                }
                            }

                            shadows[i] = Math.pow(this.shadowIntensity, shadowSum);
                            tints[i] = 1 - maxTint;
                        }
                    }
                }
                 else {
                    // Shadows are disabled
                    shadows.fill(1.0);
                    tints.fill(1.0);
                }
                // --- END MODIFIED HYBRID LOGIC ---

                const order = Array.from({length: n}, (_, i) => i).sort((a, b) => zValues[a] - zValues[b]);

                const dataRange = (maxExtent * 2) + this.lineWidth * 2;

                const canvasSize = Math.min(this.canvas.width, this.canvas.height);
                const scale = (canvasSize / dataRange) * this.zoom;
                const pyFigWidthPixels = 480.0;
                const pyPixelsPerData = pyFigWidthPixels / dataRange;
                const baseLineWidthPixels = (this.lineWidth * pyPixelsPerData) * this.zoom;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                // --- MODIFIED: Start of the new render loop ---
                for (const idx of order) {
                    const seg = segments[idx];
                    let {r, g, b} = colors[idx];
                    r /= 255; g /= 255; b /= 255;

                    // Apply lighting
                    if (renderShadows) {
                        const tintFactor = (0.50 * zNorm[idx] + 0.50 * tints[idx]) / 3;
                        r = r + (1 - r) * tintFactor;
                        g = g + (1 - g) * tintFactor;
                        b = b + (1 - b) * tintFactor; // Fixed typo (was 1-g)
                        const shadowFactor = 0.20 + 0.25 * zNorm[idx] + 0.55 * shadows[idx];
                        r *= shadowFactor; g *= shadowFactor; b *= shadowFactor;
                    } else {
                        const depthFactor = 0.70 + 0.30 * zNorm[idx];
                        r *= depthFactor; g *= depthFactor; b *= depthFactor;
                    }

                    // --- Create final color strings ---
                    const color = `rgb(${r*255|0},${g*255|0},${b*255|0})`;

                    // --- Create darker version for gap filler ---
                    const darkenFactor = 0.7; // 70% dark
                    const gapFillerColor = `rgb(${r*255*darkenFactor|0}, ${g*255*darkenFactor|0}, ${b*255*darkenFactor|0})`;

                    const x1 = centerX + seg.start.x * scale; const y1 = centerY - seg.start.y * scale;
                    const x2 = centerX + seg.end.x * scale; const y2 = centerY - seg.end.y * scale;

                    // Get width properties
                    const type = this.atomTypes[seg.origIndex];
                    let widthMultiplier = 1.0;
                    if (type === 'L') {
                        widthMultiplier = 0.5;
                    } else if (type === 'D' || type === 'R') {
                        widthMultiplier = 2.0;
                    }
                    const currentLineWidth = baseLineWidthPixels * widthMultiplier;

                    // Define outline properties
                    const outlineColor = '#000000'; // The main black outline
                    const outlinePixelWidth = 2.0;
                    const totalOutlineWidth = currentLineWidth + (outlinePixelWidth * 2);


                    if (this.outlineEnabled) {
                        // --- 3-STEP DRAW (FIXES GAPS) ---

                        // 1. Wide outline, flat ends, uses dark segment color
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.strokeStyle = gapFillerColor; // Using dark color for wide
                        this.ctx.lineWidth = totalOutlineWidth;
                        this.ctx.lineCap = 'butt';
                        this.ctx.stroke();

                        // 2. Color fill, round ends
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = currentLineWidth;
                        this.ctx.lineCap = 'round';
                        this.ctx.stroke();

                    } else {
                        // --- 1-STEP DRAW (NO OUTLINE) ---
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.strokeStyle = color;
                        this.ctx.lineWidth = currentLineWidth;
                        this.ctx.lineCap = 'round';
                        this.ctx.stroke();
                    }
                }
                // --- END of the new render loop ---
            }

            // --- REFACTORED: Main animation loop ---
            animate() {
                const now = performance.now();
                let needsRender = false;
                // MODIFIED: Removed spinRenderMode logic

                // 1. Handle inertia/spin
                if (!this.isDragging) {
                    if (Math.abs(this.spinVelocityX) > 0.0001) {
                        const rot = rotationMatrixY(this.spinVelocityX * 0.005);
                        this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix);
                        this.spinVelocityX *= 0.95; // Damping
                        needsRender = true;
                    } else {
                        this.spinVelocityX = 0;
                        // MODIFIED: Removed high-quality render flag
                    }

                    if (Math.abs(this.spinVelocityY) > 0.0001) {
                        const rot = rotationMatrixX(this.spinVelocityY * 0.005);
                        this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix);
                        this.spinVelocityY *= 0.95; // Damping
                        needsRender = true;
                    } else {
                        this.spinVelocityY = 0;
                        // MODIFIED: Removed high-quality render flag
                    }
                }

                // 2. Handle auto-rotate
                if (this.autoRotate && !this.isDragging && this.spinVelocityX === 0 && this.spinVelocityY === 0) {
                    const rot = rotationMatrixY(0.005); // Constant rotation speed
                    this.rotationMatrix = multiplyMatrices(rot, this.rotationMatrix);
                    needsRender = true;
                    // MODIFIED: Removed spinRenderMode
                }

                // 3. Handle frame playback
                if (this.isPlaying) {
                    // MODIFIED: Check for null
                    if (now - this.lastFrameAdvanceTime > this.animationSpeed && this.currentTrajectoryName) {
                        const trajectory = this.trajectoriesData[this.currentTrajectoryName];
                        if (trajectory && trajectory.frames.length > 0) {
                            let nextFrame = this.currentFrame + 1;
                            if (nextFrame >= trajectory.frames.length) {
                                nextFrame = 0;
                            }
                            this.setFrame(nextFrame); // This calls render()
                            this.lastFrameAdvanceTime = now;
                            needsRender = false; // setFrame() already called render()
                        } else {
                            this.stopAnimation();
                        }
                    }
                }

                // 4. Final render if needed
                if (needsRender) {
                    // MODIFIED: Pass no parameters
                    this.render();
                }

                // 5. Loop
                requestAnimationFrame(() => this.animate());
            }
        }

        // ============================================================================
        // MAIN APP & COLAB COMMUNICATION
        // ============================================================================

        // 1. Get config from Python
        const config = window.viewerConfig || {
            size: [800, 600],
            color: "plddt",
            default_shadow: true,
            default_outline: true,
            default_width: 3.0,
            default_rotate: false
        };

        // 2. Setup Canvas
        const canvas = document.getElementById('canvas');
        canvas.width = config.size[0];
        canvas.height = config.size[1];
        // Set column width, not main container
        document.getElementById('viewerColumn').style.width = `${config.size[0]}px`;

        // 3. Create renderer
        // Constructor now reads config and sets defaults
        window.renderer = new Pseudo3DRenderer(canvas);

        // 4. Setup general controls (now in right panel)
        const colorSelect = document.getElementById('colorSelect');
        // MODIFIED: Set dropdown value based on resolved color from python
        colorSelect.value = config.color;

        colorSelect.addEventListener('change', (e) => {
            window.renderer.colorMode = e.target.value;
            window.renderer.render();
        });

        // MODIFIED: Setup shadowEnabledCheckbox
        const shadowEnabledCheckbox = document.getElementById('shadowEnabledCheckbox');
        shadowEnabledCheckbox.checked = window.renderer.shadowEnabled; // Set default from renderer

        // NEW: Setup outlineEnabledCheckbox
        const outlineEnabledCheckbox = document.getElementById('outlineEnabledCheckbox');
        outlineEnabledCheckbox.checked = window.renderer.outlineEnabled; // Set default from renderer

        // 5. Setup animation and trajectory controls
        const controlsContainer = document.getElementById('controlsContainer');
        const playButton = document.getElementById('playButton');
        const frameSlider = document.getElementById('frameSlider');
        const frameCounter = document.getElementById('frameCounter');
        const trajectorySelect = document.getElementById('trajectorySelect');
        const speedSelect = document.getElementById('speedSelect');
        const rotationCheckbox = document.getElementById('rotationCheckbox');
        const lineWidthSlider = document.getElementById('lineWidthSlider');

        // --- NEW: Set defaults for width and rotate ---
        lineWidthSlider.value = window.renderer.lineWidth;
        rotationCheckbox.checked = window.renderer.autoRotate;

        // Pass ALL controls to the renderer
        // MODIFIED: Added outlineEnabledCheckbox
        window.renderer.setUIControls(
            controlsContainer, playButton,
            frameSlider, frameCounter, trajectorySelect,
            speedSelect, rotationCheckbox, lineWidthSlider,
            shadowEnabledCheckbox, outlineEnabledCheckbox
        );

        // 6. Add function for Python to call (for new frames)
        // --- MODIFICATION: Added trajectoryName parameter ---
        window.handlePythonUpdate = (jsonData, trajectoryName) => {
            try {
                const data = JSON.parse(jsonData);
                // --- MODIFICATION: Pass name to addFrame ---
                window.renderer.addFrame(data, trajectoryName);
            } catch (e) {
                console.error("Failed to parse JSON from Python:", e);
            }
        };
        // --- END MODIFICATION ---

        // 7. Add function for Python to start a new trajectory
        window.handlePythonNewTrajectory = (name) => {
            window.renderer.addTrajectory(name);
        };

        // 8. Add function for Python to clear everything
        window.handlePythonClearAll = () => {
            window.renderer.clearAllTrajectories();
        };

        // 9. Load initial data
        try {
            // MODIFIED: Don't load window.proteinData, as it's empty and
            // the real data will be sent by Python messages.
            // Just set the initial frame to -1 (empty).
            if (window.proteinData && window.proteinData.coords && window.proteinData.coords.length > 0) {
                // window.renderer.addFrame(window.proteinData); // OLD
                window.renderer.setFrame(-1); // NEW
            } else {
                // No initial data, start with an empty canvas.
                window.renderer.setFrame(-1);
            }
        } catch (error) {
            console.error("Error loading initial data:", error);
            window.renderer.setFrame(-1);
        }

        // 10. NEW: Add postMessage listener for Jupyter/iframe communication
        window.addEventListener('message', (event) => {
            // No origin check, but check message type for basic security
            if (event.data && event.data.type) {
                if (event.data.type === 'py2DmolUpdate') {
                    // The payload is already a JS object from Python.
                    // Stringify it to pass to the existing handler which expects a JSON string.
                    try {
                        // --- MODIFICATION: Pass trajectoryName from message ---
                        window.handlePythonUpdate(
                            JSON.stringify(event.data.payload),
                            event.data.trajectoryName
                        );
                        // --- END MODIFICATION ---
                    } catch (e) {
                         console.error("Failed to handle postMessage (update):", e, event.data.payload);
                    }
                } else if (event.data.type === 'py2DmolNewTrajectory') {
                    // The name is a string, which is what the handler expects.
                    try {
                        window.handlePythonNewTrajectory(event.data.name);
                    } catch (e) {
                         console.error("Failed to handle postMessage (new trajectory):", e, event.data.name);
                    }
                } else if (event.data.type === 'py2DmolClearAll') {
                    // New handler for clearing
                    try {
                        window.handlePythonClearAll();
                    } catch (e) {
                         console.error("Failed to handle postMessage (clear all):", e);
                    }
                }
            }
        });

        // 11. Start the main animation loop
        window.renderer.animate();

        // 12. NEW: Notify the parent window that the iframe is loaded and ready
        if (window.parent) {
            window.parent.postMessage({
                type: "py2dmol_ready",
                viewer_id: config.viewer_id
            }, "*");
        }

    </script>
</body>
</html>
